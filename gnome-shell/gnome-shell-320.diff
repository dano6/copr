diff --git a/src/core/display-private.h b/src/core/display-private.h
index 55e1d27d1b7cc003d59bb723d2a27710ae948ad4..068c710af4405a47e799e4a4b9d493523f5d6885 100644
--- a/src/core/display-private.h
+++ b/src/core/display-private.h
@@ -43,6 +43,7 @@
 #include "meta/barrier.h"
 #include "meta/boxes.h"
 #include "meta/common.h"
+#include "meta/meta-selection.h"
 #include "meta/prefs.h"
 
 typedef struct _MetaBell       MetaBell;
@@ -246,6 +247,11 @@ struct _MetaDisplay
   MetaWorkspaceManager *workspace_manager;
 
   MetaSoundPlayer *sound_player;
+
+  MetaSelectionSource *selection_source;
+  GBytes *saved_clipboard;
+  gchar *saved_clipboard_mimetype;
+  MetaSelection *selection;
 };
 
 struct _MetaDisplayClass
diff --git a/src/core/display.c b/src/core/display.c
index 0de99edb23393703e62185244f72d3938558ad0c..819c61d5c53e45d308ac15179a5ff7cc5625318a 100644
--- a/src/core/display.c
+++ b/src/core/display.c
@@ -57,6 +57,7 @@
 #include "core/frame.h"
 #include "core/keybindings-private.h"
 #include "core/main-private.h"
+#include "core/meta-clipboard-manager.h"
 #include "core/meta-workspace-manager-private.h"
 #include "core/util-private.h"
 #include "core/window-private.h"
@@ -724,6 +725,9 @@ meta_display_open (void)
 
   display->bell = meta_bell_new (display);
 
+  display->selection = meta_selection_new (display);
+  meta_clipboard_manager_init (display);
+
   if (meta_should_autostart_x11_display ())
     {
       x11_display = meta_x11_display_new (display, &error);
@@ -963,6 +967,8 @@ meta_display_close (MetaDisplay *display,
   g_clear_object (&display->workspace_manager);
   g_clear_object (&display->sound_player);
 
+  meta_clipboard_manager_shutdown (display);
+
   g_object_unref (display);
   the_display = NULL;
 
@@ -3682,3 +3688,15 @@ meta_display_get_sound_player (MetaDisplay *display)
 {
   return display->sound_player;
 }
+
+/**
+ * meta_display_get_selection:
+ * @display: a #MetaDisplay
+ *
+ * Returns: (transfer none): The selection manager of the display
+ */
+MetaSelection *
+meta_display_get_selection (MetaDisplay *display)
+{
+  return display->selection;
+}
diff --git a/src/core/meta-clipboard-manager.c b/src/core/meta-clipboard-manager.c
new file mode 100644
index 0000000000000000000000000000000000000000..1c1b587fe20a783e241d9e440495a27848cc299c
--- /dev/null
+++ b/src/core/meta-clipboard-manager.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#include "config.h"
+
+#include "core/meta-clipboard-manager.h"
+#include "meta/meta-selection-source-memory.h"
+
+#define MAX_TEXT_SIZE (4 * 1024 * 1024) /* 4MB */
+#define MAX_IMAGE_SIZE (200 * 1024 * 1024) /* 200MB */
+
+/* Supported mimetype globs, from least to most preferred */
+static struct {
+  const char *mimetype_glob;
+  ssize_t max_transfer_size;
+} supported_mimetypes[] = {
+  { "text/plain",               MAX_TEXT_SIZE },
+  { "text/plain;charset=utf-8", MAX_TEXT_SIZE },
+  { "image/*",                  MAX_IMAGE_SIZE },
+};
+
+static gboolean
+mimetype_match (const char *mimetype,
+                int        *idx,
+                gssize     *max_transfer_size)
+{
+  int i;
+
+  for (i = 0; i < G_N_ELEMENTS (supported_mimetypes); i++)
+    {
+      if (g_pattern_match_simple (supported_mimetypes[i].mimetype_glob, mimetype))
+        {
+          *max_transfer_size = supported_mimetypes[i].max_transfer_size;
+          *idx = i;
+          return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+static void
+transfer_cb (MetaSelection *selection,
+             GAsyncResult  *result,
+             GOutputStream *output)
+{
+  MetaDisplay *display = meta_get_display ();
+  GError *error = NULL;
+
+  if (!meta_selection_transfer_finish (selection, result, &error))
+    {
+      g_warning ("Failed to store clipboard: %s", error->message);
+      g_error_free (error);
+      g_object_unref (output);
+      return;
+    }
+
+  g_output_stream_close (output, NULL, NULL);
+  display->saved_clipboard =
+    g_memory_output_stream_steal_as_bytes (G_MEMORY_OUTPUT_STREAM (output));
+  g_object_unref (output);
+}
+
+static void
+owner_changed_cb (MetaSelection       *selection,
+                  MetaSelectionType    selection_type,
+                  MetaSelectionSource *new_owner,
+                  MetaDisplay         *display)
+{
+  if (selection_type != META_SELECTION_CLIPBOARD)
+    return;
+
+  if (new_owner && new_owner != display->selection_source)
+    {
+      GOutputStream *output;
+      GList *mimetypes, *l;
+      int best_idx = -1;
+      const char *best = NULL;
+      ssize_t transfer_size = -1;
+
+      /* New selection source, find the best mimetype in order to
+       * keep a copy of it.
+       */
+      g_clear_object (&display->selection_source);
+      g_clear_pointer (&display->saved_clipboard_mimetype, g_free);
+      g_clear_pointer (&display->saved_clipboard, g_bytes_unref);
+
+      mimetypes = meta_selection_get_mimetypes (selection, selection_type);
+
+      for (l = mimetypes; l; l = l->next)
+        {
+          gssize max_transfer_size;
+          int idx;
+
+          if (!mimetype_match (l->data, &idx, &max_transfer_size))
+            continue;
+
+          if (best_idx < idx)
+            {
+              best_idx = idx;
+              best = l->data;
+              transfer_size = max_transfer_size;
+            }
+        }
+
+      if (best_idx < 0)
+        return;
+
+      display->saved_clipboard_mimetype = g_strdup (best);
+      output = g_memory_output_stream_new_resizable ();
+      meta_selection_transfer_async (selection,
+                                     META_SELECTION_CLIPBOARD,
+                                     best,
+                                     transfer_size,
+                                     output,
+                                     NULL,
+                                     (GAsyncReadyCallback) transfer_cb,
+                                     output);
+    }
+  else if (!new_owner && display->saved_clipboard)
+    {
+      /* Old owner is gone, time to take over */
+      new_owner = meta_selection_source_memory_new (display->saved_clipboard_mimetype,
+                                                    display->saved_clipboard);
+      g_set_object (&display->selection_source, new_owner);
+      meta_selection_set_owner (selection, selection_type, new_owner);
+    }
+}
+
+void
+meta_clipboard_manager_init (MetaDisplay *display)
+{
+  MetaSelection *selection;
+
+  selection = meta_display_get_selection (display);
+  g_signal_connect_after (selection, "owner-changed",
+                          G_CALLBACK (owner_changed_cb), display);
+}
+
+void
+meta_clipboard_manager_shutdown (MetaDisplay *display)
+{
+  MetaSelection *selection;
+
+  g_clear_pointer (&display->saved_clipboard, g_bytes_unref);
+  g_clear_pointer (&display->saved_clipboard_mimetype, g_free);
+  selection = meta_display_get_selection (display);
+  g_signal_handlers_disconnect_by_func (selection, owner_changed_cb, display);
+}
diff --git a/src/core/meta-clipboard-manager.h b/src/core/meta-clipboard-manager.h
new file mode 100644
index 0000000000000000000000000000000000000000..2ba130f9b48eeb9dce3b7e785192ee7805322ca3
--- /dev/null
+++ b/src/core/meta-clipboard-manager.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#ifndef META_CLIPBOARD_MANAGER_H
+#define META_CLIPBOARD_MANAGER_H
+
+#include "core/display-private.h"
+
+void meta_clipboard_manager_init     (MetaDisplay *display);
+void meta_clipboard_manager_shutdown (MetaDisplay *display);
+
+#endif /* META_CLIPBOARD_MANAGER_H */
diff --git a/src/core/meta-selection-source-memory.c b/src/core/meta-selection-source-memory.c
new file mode 100644
index 0000000000000000000000000000000000000000..04b7f39a3b6d45607327f316cffdbfd1eba7eaf7
--- /dev/null
+++ b/src/core/meta-selection-source-memory.c
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#include "config.h"
+
+#include "meta/meta-selection-source-memory.h"
+
+struct _MetaSelectionSourceMemory
+{
+  MetaSelectionSource parent_instance;
+  char *mimetype;
+  GBytes *content;
+};
+
+G_DEFINE_TYPE (MetaSelectionSourceMemory,
+               meta_selection_source_memory,
+               META_TYPE_SELECTION_SOURCE)
+
+static void
+meta_selection_source_memory_read_async (MetaSelectionSource *source,
+                                         const char          *mimetype,
+                                         GCancellable        *cancellable,
+                                         GAsyncReadyCallback  callback,
+                                         gpointer             user_data)
+{
+  MetaSelectionSourceMemory *source_mem = META_SELECTION_SOURCE_MEMORY (source);
+  GInputStream *stream;
+  GTask *task;
+
+  if (g_strcmp0 (mimetype, source_mem->mimetype) != 0)
+    {
+      g_task_report_new_error (source, callback, user_data,
+                               meta_selection_source_memory_read_async,
+                               G_IO_ERROR, G_IO_ERROR_FAILED,
+                               "Mimetype not in selection");
+      return;
+    }
+
+  task = g_task_new (source, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_selection_source_memory_read_async);
+
+  stream = g_memory_input_stream_new_from_bytes (source_mem->content);
+  g_task_return_pointer (task, stream, g_object_unref);
+}
+
+static GInputStream *
+meta_selection_source_memory_read_finish (MetaSelectionSource  *source,
+                                          GAsyncResult         *result,
+                                          GError              **error)
+{
+  g_assert (g_task_get_source_tag (G_TASK (result)) ==
+            meta_selection_source_memory_read_async);
+  return g_task_propagate_pointer (G_TASK (result), error);
+}
+
+static GList *
+meta_selection_source_memory_get_mimetypes (MetaSelectionSource *source)
+{
+  MetaSelectionSourceMemory *source_mem = META_SELECTION_SOURCE_MEMORY (source);
+
+  return g_list_prepend (NULL, g_strdup (source_mem->mimetype));
+}
+
+static void
+meta_selection_source_memory_finalize (GObject *object)
+{
+  MetaSelectionSourceMemory *source_mem = META_SELECTION_SOURCE_MEMORY (object);
+
+  g_bytes_unref (source_mem->content);
+  g_free (source_mem->mimetype);
+
+  G_OBJECT_CLASS (meta_selection_source_memory_parent_class)->finalize (object);
+}
+
+static void
+meta_selection_source_memory_class_init (MetaSelectionSourceMemoryClass *klass)
+{
+  MetaSelectionSourceClass *source_class = META_SELECTION_SOURCE_CLASS (klass);
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->finalize = meta_selection_source_memory_finalize;
+
+  source_class->read_async = meta_selection_source_memory_read_async;
+  source_class->read_finish = meta_selection_source_memory_read_finish;
+  source_class->get_mimetypes = meta_selection_source_memory_get_mimetypes;
+}
+
+static void
+meta_selection_source_memory_init (MetaSelectionSourceMemory *source)
+{
+}
+
+MetaSelectionSource *
+meta_selection_source_memory_new (const char  *mimetype,
+                                  GBytes      *content)
+{
+  MetaSelectionSourceMemory *source;
+
+  g_return_val_if_fail (mimetype != NULL, NULL);
+  g_return_val_if_fail (content != NULL, NULL);
+
+  source = g_object_new (META_TYPE_SELECTION_SOURCE_MEMORY, NULL);
+  source->mimetype = g_strdup (mimetype);
+  source->content = g_bytes_ref (content);
+
+  return META_SELECTION_SOURCE (source);
+}
diff --git a/src/core/meta-selection-source.c b/src/core/meta-selection-source.c
new file mode 100644
index 0000000000000000000000000000000000000000..b076391ce963d453803cf315397f3759d25ae132
--- /dev/null
+++ b/src/core/meta-selection-source.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#include "config.h"
+
+#include "meta/meta-selection.h"
+#include "meta/meta-selection-source.h"
+
+typedef struct MetaSelectionSourcePrivate MetaSelectionSourcePrivate;
+
+struct MetaSelectionSourcePrivate
+{
+  guint active : 1;
+};
+
+G_DEFINE_TYPE_WITH_PRIVATE (MetaSelectionSource,
+                            meta_selection_source,
+                            G_TYPE_OBJECT)
+
+enum
+{
+  ACTIVE,
+  INACTIVE,
+  N_SIGNALS
+};
+
+static guint signals[N_SIGNALS] = { 0 };
+
+static void
+meta_selection_source_activated (MetaSelectionSource *source)
+{
+  MetaSelectionSourcePrivate *priv =
+    meta_selection_source_get_instance_private (source);
+
+  priv->active = TRUE;
+}
+
+static void
+meta_selection_source_deactivated (MetaSelectionSource *source)
+{
+  MetaSelectionSourcePrivate *priv =
+    meta_selection_source_get_instance_private (source);
+
+  priv->active = FALSE;
+}
+
+static void
+meta_selection_source_class_init (MetaSelectionSourceClass *klass)
+{
+  klass->activated = meta_selection_source_activated;
+  klass->deactivated = meta_selection_source_deactivated;
+
+  signals[ACTIVE] =
+    g_signal_new ("activated",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                  G_STRUCT_OFFSET (MetaSelectionSourceClass, activated),
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+  signals[INACTIVE] =
+    g_signal_new ("deactivated",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+                  G_STRUCT_OFFSET (MetaSelectionSourceClass, deactivated),
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+}
+
+static void
+meta_selection_source_init (MetaSelectionSource *source)
+{
+}
+
+void
+meta_selection_source_read_async (MetaSelectionSource *source,
+                                  const gchar         *mimetype,
+                                  GCancellable        *cancellable,
+                                  GAsyncReadyCallback  callback,
+                                  gpointer             user_data)
+{
+  g_return_if_fail (META_IS_SELECTION_SOURCE (source));
+  g_return_if_fail (mimetype != NULL);
+  g_return_if_fail (callback != NULL);
+
+  META_SELECTION_SOURCE_GET_CLASS (source)->read_async (source,
+                                                        mimetype,
+                                                        cancellable,
+                                                        callback,
+                                                        user_data);
+}
+
+/**
+ * meta_selection_source_read_finish:
+ * @source: The selection source
+ * @result: The async result
+ * @error: Location for returned error
+ *
+ * Finishes a read from the selection source.
+ *
+ * Returns: (transfer full): The resulting #GInputStream
+ */
+GInputStream *
+meta_selection_source_read_finish (MetaSelectionSource  *source,
+                                   GAsyncResult         *result,
+                                   GError              **error)
+{
+  g_return_val_if_fail (META_IS_SELECTION_SOURCE (source), NULL);
+  g_return_val_if_fail (g_task_is_valid (result, source), NULL);
+
+  return META_SELECTION_SOURCE_GET_CLASS (source)->read_finish (source,
+                                                                result,
+                                                                error);
+}
+
+/**
+ * meta_selection_source_get_mimetypes:
+ * @source: The selection source
+ *
+ * Returns the list of supported mimetypes.
+ *
+ * Returns: (element-type utf8) (transfer full): The supported mimetypes
+ */
+GList *
+meta_selection_source_get_mimetypes (MetaSelectionSource  *source)
+{
+  g_return_val_if_fail (META_IS_SELECTION_SOURCE (source), NULL);
+
+  return META_SELECTION_SOURCE_GET_CLASS (source)->get_mimetypes (source);
+}
+
+/**
+ * meta_selection_source_is_active:
+ * @source: the selection source
+ *
+ * Returns #TRUE if the source is active on a selection.
+ *
+ * Returns: #TRUE if the source owns a selection.
+ **/
+gboolean
+meta_selection_source_is_active (MetaSelectionSource *source)
+{
+  MetaSelectionSourcePrivate *priv =
+    meta_selection_source_get_instance_private (source);
+
+  g_return_val_if_fail (META_IS_SELECTION_SOURCE (source), FALSE);
+
+  return priv->active;
+}
diff --git a/src/core/meta-selection.c b/src/core/meta-selection.c
new file mode 100644
index 0000000000000000000000000000000000000000..504d322e78e6fa70ad3d2f3436c638947beb027f
--- /dev/null
+++ b/src/core/meta-selection.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#include "config.h"
+
+#include "meta/meta-selection.h"
+
+typedef struct TransferRequest TransferRequest;
+
+struct _MetaSelection
+{
+  GObject parent_instance;
+  MetaDisplay *display;
+  MetaSelectionSource *owners[META_N_SELECTION_TYPES];
+};
+
+struct TransferRequest
+{
+  MetaSelectionType selection_type;
+  GInputStream  *istream;
+  GOutputStream *ostream;
+  gssize len;
+};
+
+enum
+{
+  OWNER_CHANGED,
+  N_SIGNALS
+};
+
+static guint signals[N_SIGNALS] = { 0 };
+
+G_DEFINE_TYPE (MetaSelection, meta_selection, G_TYPE_OBJECT)
+
+static void
+meta_selection_class_init (MetaSelectionClass *klass)
+{
+  signals[OWNER_CHANGED] =
+    g_signal_new ("owner-changed",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 2,
+                  G_TYPE_UINT,
+                  META_TYPE_SELECTION_SOURCE);
+}
+
+static void
+meta_selection_init (MetaSelection *selection)
+{
+}
+
+MetaSelection *
+meta_selection_new (MetaDisplay *display)
+{
+  return g_object_new (META_TYPE_SELECTION,
+                       NULL);
+}
+
+/**
+ * meta_selection_set_owner:
+ * @selection: The selection manager
+ * @selection_type: Selection type
+ * @owner: New selection owner
+ *
+ * Sets @owner as the owner of the selection given by @selection_type,
+ * unsets any previous owner there was.
+ **/
+void
+meta_selection_set_owner (MetaSelection       *selection,
+                          MetaSelectionType    selection_type,
+                          MetaSelectionSource *owner)
+{
+  g_return_if_fail (META_IS_SELECTION (selection));
+  g_return_if_fail (selection_type < META_N_SELECTION_TYPES);
+
+  if (selection->owners[selection_type] == owner)
+    return;
+
+  if (selection->owners[selection_type])
+    g_signal_emit_by_name (selection->owners[selection_type], "deactivated");
+
+  g_set_object (&selection->owners[selection_type], owner);
+  g_signal_emit_by_name (owner, "activated");
+  g_signal_emit (selection, signals[OWNER_CHANGED], 0, selection_type, owner);
+}
+
+/**
+ * meta_selection_unset_owner:
+ * @selection: The selection manager
+ * @selection_type: Selection type
+ * @owner: Owner to unset
+ *
+ * Unsets @owner as the owner the selection given by @selection_type. If
+ * @owner does not own the selection, nothing is done.
+ **/
+void
+meta_selection_unset_owner (MetaSelection       *selection,
+                            MetaSelectionType    selection_type,
+                            MetaSelectionSource *owner)
+{
+  g_return_if_fail (META_IS_SELECTION (selection));
+  g_return_if_fail (selection_type < META_N_SELECTION_TYPES);
+
+  if (selection->owners[selection_type] == owner)
+    {
+      g_signal_emit_by_name (owner, "deactivated");
+      g_clear_object (&selection->owners[selection_type]);
+      g_signal_emit (selection, signals[OWNER_CHANGED], 0,
+                     selection_type, NULL);
+    }
+}
+
+/**
+ * meta_selection_get_mimetypes:
+ * @selection: The selection manager
+ * @selection_type: Selection to query
+ *
+ * Returns the list of supported mimetypes for the given selection type.
+ *
+ * Returns: (element-type utf8) (transfer full): The supported mimetypes
+ */
+GList *
+meta_selection_get_mimetypes (MetaSelection     *selection,
+                              MetaSelectionType  selection_type)
+{
+  g_return_val_if_fail (META_IS_SELECTION (selection), NULL);
+  g_return_val_if_fail (selection_type < META_N_SELECTION_TYPES, NULL);
+
+  if (!selection->owners[selection_type])
+    return NULL;
+
+  return meta_selection_source_get_mimetypes (selection->owners[selection_type]);
+}
+
+static TransferRequest *
+transfer_request_new (GOutputStream     *ostream,
+                      MetaSelectionType  selection_type,
+                      gssize             len)
+{
+  TransferRequest *request;
+
+  request = g_new0 (TransferRequest, 1);
+  request->ostream = g_object_ref (ostream);
+  request->selection_type = selection_type;
+  request->len = len;
+  return request;
+}
+
+static void
+transfer_request_free (TransferRequest *request)
+{
+  g_clear_object (&request->istream);
+  g_clear_object (&request->ostream);
+  g_free (request);
+}
+
+static void
+splice_cb (GOutputStream *stream,
+           GAsyncResult  *result,
+           GTask         *task)
+{
+  GError *error = NULL;
+
+  g_output_stream_splice_finish (stream, result, &error);
+  if (error)
+    {
+      g_task_return_error (task, error);
+      g_object_unref (task);
+      return;
+    }
+
+  g_task_return_boolean (task, TRUE);
+  g_object_unref (task);
+}
+
+static void
+write_cb (GOutputStream *stream,
+          GAsyncResult  *result,
+          GTask         *task)
+{
+  GError *error = NULL;
+
+  g_output_stream_write_bytes_finish (stream, result, &error);
+  if (error)
+    {
+      g_task_return_error (task, error);
+      g_object_unref (task);
+      return;
+    }
+
+  g_task_return_boolean (task, TRUE);
+  g_object_unref (task);
+}
+
+static void
+read_cb (GInputStream *stream,
+         GAsyncResult *result,
+         GTask        *task)
+{
+  TransferRequest *request;
+  GError *error = NULL;
+  GBytes *bytes;
+
+  bytes = g_input_stream_read_bytes_finish (stream, result, &error);
+  if (error)
+    {
+      g_task_return_error (task, error);
+      g_object_unref (task);
+      return;
+    }
+
+  request = g_task_get_task_data (task);
+  g_output_stream_write_bytes_async (request->ostream,
+                                     bytes,
+                                     G_PRIORITY_DEFAULT,
+                                     g_task_get_cancellable (task),
+                                     (GAsyncReadyCallback) write_cb,
+                                     task);
+  g_bytes_unref (bytes);
+}
+
+static void
+source_read_cb (MetaSelectionSource *source,
+                GAsyncResult        *result,
+                GTask               *task)
+{
+  TransferRequest *request;
+  GInputStream *stream;
+  GError *error = NULL;
+
+  stream = meta_selection_source_read_finish (source, result, &error);
+  if (!stream)
+    {
+      g_task_return_error (task, error);
+      return;
+    }
+
+  request = g_task_get_task_data (task);
+  request->istream = stream;
+
+  if (request->len < 0)
+    {
+      g_output_stream_splice_async (request->ostream,
+                                    request->istream,
+                                    G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE |
+                                    G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET,
+                                    G_PRIORITY_DEFAULT,
+                                    g_task_get_cancellable (task),
+                                    (GAsyncReadyCallback) splice_cb,
+                                    task);
+    }
+  else
+    {
+      g_input_stream_read_bytes_async (request->istream,
+                                       (gsize) request->len,
+                                       G_PRIORITY_DEFAULT,
+                                       g_task_get_cancellable (task),
+                                       (GAsyncReadyCallback) read_cb,
+                                       task);
+    }
+}
+
+/**
+ * meta_selection_transfer_async:
+ * @selection: The selection manager
+ * @selection_type: Selection type
+ * @mimetype: Mimetype to transfer
+ * @size: Maximum size to transfer, -1 for unlimited
+ * @output: Output stream to write contents to
+ * @cancellable: Cancellable
+ * @callback: User callback
+ * @user_data: User data
+ *
+ * Requests a transfer of @mimetype on the selection given by
+ * @selection_type.
+ **/
+void
+meta_selection_transfer_async (MetaSelection        *selection,
+                               MetaSelectionType     selection_type,
+                               const char           *mimetype,
+                               gssize                size,
+                               GOutputStream        *output,
+                               GCancellable         *cancellable,
+                               GAsyncReadyCallback   callback,
+                               gpointer              user_data)
+{
+  GTask *task;
+
+  g_return_if_fail (META_IS_SELECTION (selection));
+  g_return_if_fail (selection_type < META_N_SELECTION_TYPES);
+  g_return_if_fail (G_IS_OUTPUT_STREAM (output));
+  g_return_if_fail (mimetype != NULL);
+
+  task = g_task_new (selection, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_selection_transfer_async);
+
+  g_task_set_task_data (task,
+                        transfer_request_new (output, selection_type, size),
+                        (GDestroyNotify) transfer_request_free);
+  meta_selection_source_read_async (selection->owners[selection_type],
+                                    mimetype,
+                                    cancellable,
+                                    (GAsyncReadyCallback) source_read_cb,
+                                    task);
+}
+
+/**
+ * meta_selection_transfer_finish:
+ * @selection: The selection manager
+ * @result: The async result
+ * @error: Location for returned error, or %NULL
+ *
+ * Finishes the transfer of a queried mimetype.
+ *
+ * Returns: #TRUE if the transfer was successful.
+ **/
+gboolean
+meta_selection_transfer_finish (MetaSelection  *selection,
+                                GAsyncResult   *result,
+                                GError        **error)
+{
+  g_return_val_if_fail (g_task_is_valid (result, selection), FALSE);
+  g_return_val_if_fail (g_task_get_source_tag (G_TASK (result)) ==
+                        meta_selection_transfer_async, FALSE);
+
+  return g_task_propagate_boolean (G_TASK (result), error);
+}
diff --git a/src/meson.build b/src/meson.build
index 8ed6cb0cfdbe28896c320cf90741aa52a6211183..1370eac0b1d36597d990fda227c259cbd87e56d2 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -329,6 +329,8 @@ mutter_sources = [
   'core/meta-accel-parse.h',
   'core/meta-border.c',
   'core/meta-border.h',
+  'core/meta-clipboard-manager.c',
+  'core/meta-clipboard-manager.h',
   'core/meta-close-dialog.c',
   'core/meta-close-dialog-default.c',
   'core/meta-close-dialog-default-private.h',
@@ -340,6 +342,9 @@ mutter_sources = [
   'core/meta-inhibit-shortcuts-dialog-default.c',
   'core/meta-inhibit-shortcuts-dialog-default-private.h',
   'core/meta-launch-context.c',
+  'core/meta-selection.c',
+  'core/meta-selection-source.c',
+  'core/meta-selection-source-memory.c',
   'core/meta-sound-player.c',
   'core/meta-workspace-manager.c',
   'core/meta-workspace-manager-private.h',
@@ -374,11 +379,19 @@ mutter_sources = [
   'x11/group-props.h',
   'x11/iconcache.c',
   'x11/iconcache.h',
+  'x11/meta-selection-source-x11.c',
+  'x11/meta-selection-source-x11-private.h',
   'x11/meta-startup-notification-x11.c',
   'x11/meta-startup-notification-x11.h',
   'x11/meta-x11-display.c',
   'x11/meta-x11-display-private.h',
   'x11/meta-x11-errors.c',
+  'x11/meta-x11-selection.c',
+  'x11/meta-x11-selection-private.h',
+  'x11/meta-x11-selection-input-stream.c',
+  'x11/meta-x11-selection-input-stream-private.h',
+  'x11/meta-x11-selection-output-stream.c',
+  'x11/meta-x11-selection-output-stream-private.h',
   'x11/mutter-Xatomtype.h',
   'x11/session.c',
   'x11/session.h',
@@ -444,6 +457,8 @@ if have_wayland
     'wayland/meta-pointer-confinement-wayland.h',
     'wayland/meta-pointer-lock-wayland.c',
     'wayland/meta-pointer-lock-wayland.h',
+    'wayland/meta-selection-source-wayland.c',
+    'wayland/meta-selection-source-wayland-private.h',
     'wayland/meta-wayland-actor-surface.c',
     'wayland/meta-wayland-actor-surface.h',
     'wayland/meta-wayland-buffer.c',
@@ -539,8 +554,8 @@ if have_wayland
     'wayland/meta-xwayland-grab-keyboard.h',
     'wayland/meta-xwayland.h',
     'wayland/meta-xwayland-private.h',
-    'wayland/meta-xwayland-selection.c',
-    'wayland/meta-xwayland-selection-private.h',
+    'wayland/meta-xwayland-dnd.c',
+    'wayland/meta-xwayland-dnd-private.h',
   ]
 endif
 
diff --git a/src/meta/display.h b/src/meta/display.h
index 170392048c83f64ce955068309a9963f2f721213..09c1f99ecf697074ce84a5753beae89fc8f87b6b 100644
--- a/src/meta/display.h
+++ b/src/meta/display.h
@@ -294,4 +294,7 @@ MetaStartupNotification * meta_display_get_startup_notification (MetaDisplay *di
 META_EXPORT
 MetaSoundPlayer * meta_display_get_sound_player (MetaDisplay *display);
 
+META_EXPORT
+MetaSelection * meta_display_get_selection (MetaDisplay *display);
+
 #endif
diff --git a/src/meta/meson.build b/src/meta/meson.build
index 2bd50e4f7897b7c45481921dd64b9e33753aad6b..14caec58d3059845ad647b58058c60ba01912292 100644
--- a/src/meta/meson.build
+++ b/src/meta/meson.build
@@ -22,6 +22,9 @@ mutter_public_headers = [
   'meta-monitor-manager.h',
   'meta-plugin.h',
   'meta-remote-access-controller.h',
+  'meta-selection.h',
+  'meta-selection-source.h',
+  'meta-selection-source-memory.h',
   'meta-settings.h',
   'meta-shadow-factory.h',
   'meta-shaped-texture.h',
diff --git a/src/meta/meta-selection-source-memory.h b/src/meta/meta-selection-source-memory.h
new file mode 100644
index 0000000000000000000000000000000000000000..b72e127623e44360a088974eef1cade2583338f8
--- /dev/null
+++ b/src/meta/meta-selection-source-memory.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#ifndef META_MEMORY_SELECTION_SOURCE_H
+#define META_MEMORY_SELECTION_SOURCE_H
+
+#include "meta/meta-selection-source.h"
+
+#define META_TYPE_SELECTION_SOURCE_MEMORY (meta_selection_source_memory_get_type ())
+
+META_EXPORT
+G_DECLARE_FINAL_TYPE (MetaSelectionSourceMemory,
+                      meta_selection_source_memory,
+                      META, SELECTION_SOURCE_MEMORY,
+                      MetaSelectionSource)
+
+META_EXPORT
+MetaSelectionSource * meta_selection_source_memory_new (const char *mimetype,
+                                                        GBytes     *content);
+
+#endif /* META_SELECTION_SOURCE_MEMORY_H */
diff --git a/src/meta/meta-selection-source.h b/src/meta/meta-selection-source.h
new file mode 100644
index 0000000000000000000000000000000000000000..a341bede11390504866cbfb99375c9a4097eb9d4
--- /dev/null
+++ b/src/meta/meta-selection-source.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#ifndef META_SELECTION_SOURCE_H
+#define META_SELECTION_SOURCE_H
+
+#include <gio/gio.h>
+
+#include <meta/common.h>
+
+typedef enum
+{
+  META_SELECTION_PRIMARY,
+  META_SELECTION_CLIPBOARD,
+  META_SELECTION_DND,
+  META_N_SELECTION_TYPES,
+} MetaSelectionType;
+
+typedef struct _MetaSelectionSourceClass MetaSelectionSourceClass;
+typedef struct _MetaSelectionSource MetaSelectionSource;
+
+#define META_TYPE_SELECTION_SOURCE (meta_selection_source_get_type ())
+
+META_EXPORT
+G_DECLARE_DERIVABLE_TYPE (MetaSelectionSource,
+                          meta_selection_source,
+                          META, SELECTION_SOURCE,
+                          GObject)
+
+struct _MetaSelectionSourceClass
+{
+  GObjectClass parent_class;
+
+  void           (* activated)     (MetaSelectionSource *source);
+  void           (* deactivated)   (MetaSelectionSource *source);
+
+  GList *        (* get_mimetypes) (MetaSelectionSource  *source);
+
+  void           (* read_async)    (MetaSelectionSource  *source,
+                                    const gchar          *mimetype,
+                                    GCancellable         *cancellable,
+                                    GAsyncReadyCallback   callback,
+                                    gpointer              user_data);
+  GInputStream * (* read_finish)   (MetaSelectionSource  *source,
+                                    GAsyncResult         *result,
+                                    GError              **error);
+};
+
+META_EXPORT
+void           meta_selection_source_read_async  (MetaSelectionSource  *source,
+                                                  const gchar          *mimetype,
+                                                  GCancellable         *cancellable,
+                                                  GAsyncReadyCallback   callback,
+                                                  gpointer              user_data);
+
+META_EXPORT
+GInputStream * meta_selection_source_read_finish (MetaSelectionSource  *source,
+                                                  GAsyncResult         *result,
+                                                  GError              **error);
+
+META_EXPORT
+GList *  meta_selection_source_get_mimetypes     (MetaSelectionSource  *source);
+
+META_EXPORT
+gboolean meta_selection_source_is_active         (MetaSelectionSource  *source);
+
+#endif /* META_SELECTION_SOURCE_H */
diff --git a/src/meta/meta-selection.h b/src/meta/meta-selection.h
new file mode 100644
index 0000000000000000000000000000000000000000..ef86dce1dd0d00210ac3a339b30f8f13f7ab92f4
--- /dev/null
+++ b/src/meta/meta-selection.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#ifndef META_SELECTION_H
+#define META_SELECTION_H
+
+#include <gio/gio.h>
+
+#include <meta/common.h>
+#include <meta/display.h>
+#include <meta/meta-selection-source.h>
+
+#define META_TYPE_SELECTION (meta_selection_get_type ())
+
+META_EXPORT
+G_DECLARE_FINAL_TYPE (MetaSelection,
+                      meta_selection,
+                      META, SELECTION,
+                      GObject)
+
+META_EXPORT
+MetaSelection *
+         meta_selection_new                  (MetaDisplay *display);
+
+META_EXPORT
+void     meta_selection_set_owner            (MetaSelection        *selection,
+                                              MetaSelectionType     selection_type,
+                                              MetaSelectionSource  *owner);
+META_EXPORT
+void     meta_selection_unset_owner          (MetaSelection        *selection,
+                                              MetaSelectionType     selection_type,
+                                              MetaSelectionSource  *owner);
+
+META_EXPORT
+GList *  meta_selection_get_mimetypes        (MetaSelection        *selection,
+                                              MetaSelectionType     selection_type);
+
+META_EXPORT
+void     meta_selection_transfer_async       (MetaSelection        *selection,
+                                              MetaSelectionType     selection_type,
+                                              const gchar          *mimetype,
+                                              gssize                size,
+                                              GOutputStream        *output,
+                                              GCancellable         *cancellable,
+                                              GAsyncReadyCallback   callback,
+                                              gpointer              user_data);
+META_EXPORT
+gboolean meta_selection_transfer_finish      (MetaSelection        *selection,
+                                              GAsyncResult         *result,
+                                              GError              **error);
+
+#endif /* META_SELECTION_H */
diff --git a/src/meta/types.h b/src/meta/types.h
index f9ff90b9b18007d0d3178114c9cea70eaa96bba8..49fb5681667e35c12ac7dd1f8dd8c49de5647b9a 100644
--- a/src/meta/types.h
+++ b/src/meta/types.h
@@ -43,5 +43,6 @@ typedef struct _MetaDnd         MetaDnd;
 typedef struct _MetaSettings    MetaSettings;
 
 typedef struct _MetaWorkspaceManager MetaWorkspaceManager;
+typedef struct _MetaSelection   MetaSelection;
 
 #endif
diff --git a/src/wayland/meta-selection-source-wayland-private.h b/src/wayland/meta-selection-source-wayland-private.h
new file mode 100644
index 0000000000000000000000000000000000000000..6affc77a8ed47fdb54637402db4c9b44732b4904
--- /dev/null
+++ b/src/wayland/meta-selection-source-wayland-private.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#ifndef META_SELECTION_SOURCE_WAYLAND_H
+#define META_SELECTION_SOURCE_WAYLAND_H
+
+#include <wayland-server.h>
+
+#include "meta/meta-selection-source.h"
+
+#define META_TYPE_SELECTION_SOURCE_WAYLAND (meta_selection_source_wayland_get_type ())
+
+G_DECLARE_FINAL_TYPE (MetaSelectionSourceWayland,
+                      meta_selection_source_wayland,
+                      META, SELECTION_SOURCE_WAYLAND,
+                      MetaSelectionSource)
+
+typedef void (* MetaWaylandSendFunc) (struct wl_resource *resource,
+                                      const char         *mimetype,
+                                      int                 fd);
+typedef void (* MetaWaylandCancelFunc) (struct wl_resource *resource);
+
+MetaSelectionSource * meta_selection_source_wayland_new (struct wl_resource    *resource,
+                                                         GList                 *mime_types,
+                                                         MetaWaylandSendFunc    send_func,
+                                                         MetaWaylandCancelFunc  cancel_func);
+
+#endif /* META_SELECTION_SOURCE_WAYLAND_H */
diff --git a/src/wayland/meta-selection-source-wayland.c b/src/wayland/meta-selection-source-wayland.c
new file mode 100644
index 0000000000000000000000000000000000000000..7031c911ee3ecf51b3a217bbca71a87ded19b633
--- /dev/null
+++ b/src/wayland/meta-selection-source-wayland.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#include "config.h"
+
+#include <glib-unix.h>
+#include <gio/gunixinputstream.h>
+
+#include "wayland/meta-selection-source-wayland-private.h"
+
+struct _MetaSelectionSourceWayland
+{
+  MetaSelectionSource parent_instance;
+  GList *mimetypes;
+  MetaWaylandSendFunc send_func;
+  MetaWaylandCancelFunc cancel_func;
+  struct wl_resource *resource;
+};
+
+G_DEFINE_TYPE (MetaSelectionSourceWayland, meta_selection_source_wayland,
+               META_TYPE_SELECTION_SOURCE)
+
+static void
+meta_selection_source_wayland_finalize (GObject *object)
+{
+  MetaSelectionSourceWayland *source_wayland = META_SELECTION_SOURCE_WAYLAND (object);
+
+  g_list_free_full (source_wayland->mimetypes, g_free);
+
+  G_OBJECT_CLASS (meta_selection_source_wayland_parent_class)->finalize (object);
+}
+
+static void
+meta_selection_source_wayland_read_async (MetaSelectionSource *source,
+                                          const gchar         *mimetype,
+                                          GCancellable        *cancellable,
+                                          GAsyncReadyCallback  callback,
+                                          gpointer             user_data)
+{
+  MetaSelectionSourceWayland *source_wayland = META_SELECTION_SOURCE_WAYLAND (source);
+  GInputStream *stream;
+  GTask *task;
+  int pipe_fds[2];
+
+  if (!g_unix_open_pipe (pipe_fds, FD_CLOEXEC, NULL))
+    {
+      g_task_report_new_error (source, callback, user_data,
+                               meta_selection_source_wayland_read_async,
+                               G_IO_ERROR, G_IO_ERROR_FAILED,
+                               "Could not open pipe to read wayland selection");
+      return;
+    }
+
+  if (!g_unix_set_fd_nonblocking (pipe_fds[0], TRUE, NULL) ||
+      !g_unix_set_fd_nonblocking (pipe_fds[1], TRUE, NULL))
+    {
+      g_task_report_new_error (source, callback, user_data,
+                               meta_selection_source_wayland_read_async,
+                               G_IO_ERROR, G_IO_ERROR_FAILED,
+                               "Could not make pipe nonblocking");
+      close (pipe_fds[0]);
+      close (pipe_fds[1]);
+      return;
+    }
+
+  task = g_task_new (source, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_selection_source_wayland_read_async);
+
+  stream = g_unix_input_stream_new (pipe_fds[0], TRUE);
+  source_wayland->send_func (source_wayland->resource, mimetype, pipe_fds[1]);
+  close (pipe_fds[1]);
+
+  g_task_return_pointer (task, stream, g_object_unref);
+  g_object_unref (task);
+}
+
+static GInputStream *
+meta_selection_source_wayland_read_finish (MetaSelectionSource  *source,
+                                           GAsyncResult         *result,
+                                           GError              **error)
+{
+  g_return_val_if_fail (g_task_is_valid (result, source), FALSE);
+  g_return_val_if_fail (g_task_get_source_tag (G_TASK (result)) ==
+                        meta_selection_source_wayland_read_async, FALSE);
+
+  return g_task_propagate_pointer (G_TASK (result), error);
+}
+
+static GList *
+meta_selection_source_wayland_get_mimetypes (MetaSelectionSource  *source)
+{
+  MetaSelectionSourceWayland *source_wayland = META_SELECTION_SOURCE_WAYLAND (source);
+
+  return g_list_copy_deep (source_wayland->mimetypes,
+                           (GCopyFunc) g_strdup, NULL);
+}
+
+static void
+meta_selection_source_wayland_deactivated (MetaSelectionSource *source)
+{
+  MetaSelectionSourceWayland *source_wayland =
+    META_SELECTION_SOURCE_WAYLAND (source);
+
+  source_wayland->cancel_func (source_wayland->resource);
+  META_SELECTION_SOURCE_CLASS (meta_selection_source_wayland_parent_class)->deactivated (source);
+}
+
+static void
+meta_selection_source_wayland_class_init (MetaSelectionSourceWaylandClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  MetaSelectionSourceClass *source_class = META_SELECTION_SOURCE_CLASS (klass);
+
+  object_class->finalize = meta_selection_source_wayland_finalize;
+
+  source_class->deactivated = meta_selection_source_wayland_deactivated;
+
+  source_class->read_async = meta_selection_source_wayland_read_async;
+  source_class->read_finish = meta_selection_source_wayland_read_finish;
+  source_class->get_mimetypes = meta_selection_source_wayland_get_mimetypes;
+}
+
+static void
+meta_selection_source_wayland_init (MetaSelectionSourceWayland *source)
+{
+}
+
+MetaSelectionSource *
+meta_selection_source_wayland_new (struct wl_resource    *resource,
+                                   GList                 *mime_types,
+                                   MetaWaylandSendFunc    send_func,
+                                   MetaWaylandCancelFunc  cancel_func)
+{
+  MetaSelectionSourceWayland *source_wayland;
+
+  source_wayland = g_object_new (META_TYPE_SELECTION_SOURCE_WAYLAND, NULL);
+  source_wayland->mimetypes = g_list_copy_deep (mime_types,
+                                                (GCopyFunc) g_strdup, NULL);
+  source_wayland->send_func = send_func;
+  source_wayland->cancel_func = cancel_func;
+  source_wayland->resource = resource;
+
+  return META_SELECTION_SOURCE (source_wayland);
+}
diff --git a/src/wayland/meta-wayland-data-device.c b/src/wayland/meta-wayland-data-device.c
index 122604965b4f593c4718c9acd5475080c8649db6..1291945de67d22a58b83f64ca320767c063dd652 100644
--- a/src/wayland/meta-wayland-data-device.c
+++ b/src/wayland/meta-wayland-data-device.c
@@ -27,6 +27,7 @@
 #include "wayland/meta-wayland-data-device.h"
 #include "wayland/meta-wayland-data-device-private.h"
 
+#include <gio/gunixoutputstream.h>
 #include <glib-unix.h>
 #include <glib.h>
 #include <stdio.h>
@@ -35,6 +36,7 @@
 #include <unistd.h>
 
 #include "compositor/meta-dnd-actor-private.h"
+#include "wayland/meta-selection-source-wayland-private.h"
 #include "wayland/meta-wayland-dnd-surface.h"
 #include "wayland/meta-wayland-pointer.h"
 #include "wayland/meta-wayland-private.h"
@@ -101,6 +103,11 @@ meta_wayland_data_source_primary_new (struct wl_resource *resource);
 static void
 drag_grab_data_source_destroyed (gpointer data, GObject *where_the_object_was);
 
+static struct wl_resource * create_and_send_clipboard_offer (MetaWaylandDataDevice *data_device,
+                                                             struct wl_resource    *target);
+static struct wl_resource * create_and_send_primary_offer   (MetaWaylandDataDevice *data_device,
+                                                             struct wl_resource    *target);
+
 static void
 unbind_resource (struct wl_resource *resource)
 {
@@ -364,16 +371,60 @@ data_offer_accept (struct wl_client *client,
   offer->accepted = mime_type != NULL;
 }
 
+static void
+transfer_cb (MetaSelection *selection,
+             GAsyncResult  *res,
+             GOutputStream *stream)
+{
+  GError *error = NULL;
+
+  if (!meta_selection_transfer_finish (selection, res, &error))
+    {
+      g_warning ("Could not fetch selection data: %s", error->message);
+      g_error_free (error);
+    }
+
+  g_output_stream_close (stream, NULL, NULL);
+}
+
 static void
 data_offer_receive (struct wl_client *client, struct wl_resource *resource,
                     const char *mime_type, int32_t fd)
 {
   MetaWaylandDataOffer *offer = wl_resource_get_user_data (resource);
+  MetaDisplay *display = meta_get_display ();
+  MetaSelectionType selection_type;
+  GList *mime_types;
+  gboolean found;
 
-  if (offer->source)
-    meta_wayland_data_source_send (offer->source, mime_type, fd);
+  if (offer->dnd_actions != 0)
+    selection_type = META_SELECTION_DND;
   else
-    close (fd);
+    selection_type = META_SELECTION_CLIPBOARD;
+
+  mime_types = meta_selection_get_mimetypes (meta_display_get_selection (display),
+                                             selection_type);
+  found = g_list_find_custom (mime_types, mime_type, (GCompareFunc) g_strcmp0) != NULL;
+  g_list_free_full (mime_types, g_free);
+
+  if (found)
+    {
+      GOutputStream *stream;
+
+      stream = g_unix_output_stream_new (fd, TRUE);
+      meta_selection_transfer_async (meta_display_get_selection (display),
+                                     selection_type,
+                                     mime_type,
+                                     -1,
+                                     stream,
+                                     NULL,
+                                     (GAsyncReadyCallback) transfer_cb,
+                                     stream);
+    }
+  else
+    {
+      close (fd);
+    }
 }
 
 static void
@@ -460,26 +511,31 @@ static void
 primary_offer_receive (struct wl_client *client, struct wl_resource *resource,
                        const char *mime_type, int32_t fd)
 {
-  MetaWaylandDataOffer *offer = wl_resource_get_user_data (resource);
-  MetaWaylandDataSource *source = offer->source;
-  MetaWaylandSeat *seat;
+  MetaDisplay *display = meta_get_display ();
+  GOutputStream *stream;
+  GList *mime_types;
+  gboolean found;
 
-  if (!offer->source)
-    {
-      close (fd);
-      return;
-    }
-
-  seat = meta_wayland_data_source_get_seat (source);
+  mime_types = meta_selection_get_mimetypes (meta_display_get_selection (display),
+                                             META_SELECTION_CLIPBOARD);
+  found = g_list_find_custom (mime_types, mime_type, (GCompareFunc) g_strcmp0) != NULL;
+  g_list_free_full (mime_types, g_free);
 
-  if (wl_resource_get_client (offer->resource) !=
-      meta_wayland_keyboard_get_focus_client (seat->keyboard))
+  if (!found)
     {
       close (fd);
       return;
     }
 
-  meta_wayland_data_source_send (offer->source, mime_type, fd);
+  stream = g_unix_output_stream_new (fd, TRUE);
+  meta_selection_transfer_async (meta_display_get_selection (display),
+                                 META_SELECTION_PRIMARY,
+                                 mime_type,
+                                 -1,
+                                 stream,
+                                 NULL,
+                                 (GAsyncReadyCallback) transfer_cb,
+                                 stream);
 }
 
 static const struct gtk_primary_selection_offer_interface primary_offer_interface = {
@@ -554,8 +610,8 @@ destroy_primary_offer (struct wl_resource *resource)
 }
 
 static struct wl_resource *
-meta_wayland_data_source_send_offer (MetaWaylandDataSource *source,
-                                     struct wl_resource *target)
+create_and_send_dnd_offer (MetaWaylandDataSource *source,
+                           struct wl_resource *target)
 {
   MetaWaylandDataSourcePrivate *priv =
     meta_wayland_data_source_get_instance_private (source);
@@ -583,35 +639,6 @@ meta_wayland_data_source_send_offer (MetaWaylandDataSource *source,
   return offer->resource;
 }
 
-static struct wl_resource *
-meta_wayland_data_source_send_primary_offer (MetaWaylandDataSource *source,
-					     struct wl_resource    *target)
-{
-  MetaWaylandDataSourcePrivate *priv =
-    meta_wayland_data_source_get_instance_private (source);
-  MetaWaylandDataOffer *offer = g_slice_new0 (MetaWaylandDataOffer);
-  char **p;
-
-  offer->source = source;
-  g_object_add_weak_pointer (G_OBJECT (source), (gpointer *)&offer->source);
-  offer->resource = wl_resource_create (wl_resource_get_client (target),
-                                        &gtk_primary_selection_offer_interface,
-                                        wl_resource_get_version (target), 0);
-  wl_resource_set_implementation (offer->resource,
-                                  &primary_offer_interface,
-                                  offer,
-                                  destroy_primary_offer);
-
-  gtk_primary_selection_device_send_data_offer (target, offer->resource);
-
-  wl_array_for_each (p, &priv->mime_types)
-    gtk_primary_selection_offer_send_offer (offer->resource, *p);
-
-  meta_wayland_data_source_set_current_offer (source, offer);
-
-  return offer->resource;
-}
-
 static void
 data_source_offer (struct wl_client *client,
                    struct wl_resource *resource, const char *type)
@@ -712,6 +739,34 @@ struct _MetaWaylandDragGrab {
   guint                   need_initial_focus : 1;
 };
 
+static void
+set_selection_source (MetaWaylandDataDevice *data_device,
+                      MetaSelectionType      selection_type,
+                      MetaSelectionSource   *selection_source)
+
+{
+  MetaDisplay *display = meta_get_display ();
+
+  meta_selection_set_owner (meta_display_get_selection (display),
+                            selection_type, selection_source);
+  g_set_object (&data_device->owners[selection_type], selection_source);
+}
+
+static void
+unset_selection_source (MetaWaylandDataDevice *data_device,
+                        MetaSelectionType      selection_type)
+{
+  MetaDisplay *display = meta_get_display ();
+
+  if (!data_device->owners[selection_type])
+    return;
+
+  meta_selection_unset_owner (meta_display_get_selection (display),
+                              selection_type,
+                              data_device->owners[selection_type]);
+  g_clear_object (&data_device->owners[selection_type]);
+}
+
 static void
 destroy_drag_focus (struct wl_listener *listener, void *data)
 {
@@ -817,7 +872,7 @@ meta_wayland_drag_grab_set_focus (MetaWaylandDragGrab *drag_grab,
   data_device_resource = wl_resource_find_for_client (&seat->data_device.resource_list, client);
 
   if (source && data_device_resource)
-    offer = meta_wayland_data_source_send_offer (source, data_device_resource);
+    offer = create_and_send_dnd_offer (source, data_device_resource);
 
   drag_grab->drag_focus = surface;
   drag_grab->drag_focus_destroy_handler_id =
@@ -1005,6 +1060,7 @@ drag_grab_button (MetaWaylandPointerGrab *grab,
           meta_wayland_data_source_cancel (source);
           meta_wayland_data_source_set_current_offer (source, NULL);
           meta_wayland_data_device_set_dnd_source (&seat->data_device, NULL);
+          unset_selection_source (&seat->data_device, META_SELECTION_DND);
           success= FALSE;
         }
 
@@ -1066,6 +1122,7 @@ destroy_data_device_origin (struct wl_listener *listener, void *data)
 
   drag_grab->drag_origin = NULL;
   meta_wayland_data_device_set_dnd_source (&drag_grab->seat->data_device, NULL);
+  unset_selection_source (&drag_grab->seat->data_device, META_SELECTION_DND);
   data_device_end_drag_grab (drag_grab);
 }
 
@@ -1076,6 +1133,7 @@ drag_grab_data_source_destroyed (gpointer data, GObject *where_the_object_was)
 
   drag_grab->drag_data_source = NULL;
   meta_wayland_data_device_set_dnd_source (&drag_grab->seat->data_device, NULL);
+  unset_selection_source (&drag_grab->seat->data_device, META_SELECTION_DND);
   data_device_end_drag_grab (drag_grab);
 }
 
@@ -1091,6 +1149,18 @@ destroy_data_device_icon (struct wl_listener *listener, void *data)
     clutter_actor_remove_all_children (drag_grab->feedback_actor);
 }
 
+static GList *
+copy_string_array_to_list (struct wl_array *array)
+{
+  GList *l = NULL;
+  char **p;
+
+  wl_array_for_each (p, array)
+    l = g_list_prepend (l, g_strdup (*p));
+
+  return l;
+}
+
 void
 meta_wayland_data_device_start_drag (MetaWaylandDataDevice                 *data_device,
                                      struct wl_client                      *client,
@@ -1189,6 +1259,8 @@ data_device_start_drag (struct wl_client *client,
   MetaWaylandSeat *seat = wl_container_of (data_device, seat, data_device);
   MetaWaylandSurface *surface = NULL, *icon_surface = NULL;
   MetaWaylandDataSource *drag_source = NULL;
+  MetaSelectionSource *selection_source;
+  GList *mimetypes;
 
   if (origin_resource)
     surface = wl_resource_get_user_data (origin_resource);
@@ -1224,6 +1296,15 @@ data_device_start_drag (struct wl_client *client,
       return;
     }
 
+  mimetypes = copy_string_array_to_list (meta_wayland_data_source_get_mime_types (drag_source));
+  selection_source = meta_selection_source_wayland_new (source_resource,
+                                                        mimetypes,
+                                                        wl_data_source_send_send,
+                                                        wl_data_source_send_cancelled);
+  g_list_free_full (mimetypes, g_free);
+  set_selection_source (data_device, META_SELECTION_DND,
+                        selection_source);
+
   meta_wayland_pointer_set_focus (seat->pointer, NULL);
   meta_wayland_data_device_start_drag (data_device, client,
                                        &drag_grab_interface,
@@ -1256,6 +1337,7 @@ selection_data_source_destroyed (gpointer data, GObject *object_was_here)
     }
 
   wl_signal_emit (&data_device->selection_ownership_signal, NULL);
+  unset_selection_source (data_device, META_SELECTION_CLIPBOARD);
 }
 
 static void
@@ -1315,6 +1397,8 @@ meta_wayland_source_drop_performed (MetaWaylandDataSource *source)
 static void
 meta_wayland_source_drag_finished (MetaWaylandDataSource *source)
 {
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaWaylandDataDevice *data_device = &compositor->seat->data_device;
   MetaWaylandDataSourceWayland *source_wayland =
     META_WAYLAND_DATA_SOURCE_WAYLAND (source);
   enum wl_data_device_manager_dnd_action action;
@@ -1328,6 +1412,8 @@ meta_wayland_source_drag_finished (MetaWaylandDataSource *source)
   if (wl_resource_get_version (source_wayland->resource) >=
       WL_DATA_SOURCE_DND_FINISHED_SINCE_VERSION)
     wl_data_source_send_dnd_finished (source_wayland->resource);
+
+  unset_selection_source (data_device, META_SELECTION_DND);
 }
 
 static void
@@ -1554,7 +1640,7 @@ meta_wayland_data_device_set_selection (MetaWaylandDataDevice *data_device,
                                         guint32 serial)
 {
   MetaWaylandSeat *seat = wl_container_of (data_device, seat, data_device);
-  struct wl_resource *data_device_resource, *offer;
+  struct wl_resource *data_device_resource;
   struct wl_client *focus_client;
 
   if (data_device->selection_data_source &&
@@ -1579,24 +1665,37 @@ meta_wayland_data_device_set_selection (MetaWaylandDataDevice *data_device,
       data_device_resource = wl_resource_find_for_client (&data_device->resource_list, focus_client);
       if (data_device_resource)
         {
-          if (data_device->selection_data_source)
-            {
-              offer = meta_wayland_data_source_send_offer (data_device->selection_data_source, data_device_resource);
-              wl_data_device_send_selection (data_device_resource, offer);
-            }
-          else
-            {
-              wl_data_device_send_selection (data_device_resource, NULL);
-            }
+          struct wl_resource *offer;
+          offer = create_and_send_clipboard_offer (data_device, data_device_resource);
+          wl_data_device_send_selection (data_device_resource, offer);
         }
     }
 
   if (source)
     {
+      MetaWaylandDataSourceWayland *source_wayland =
+        META_WAYLAND_DATA_SOURCE_WAYLAND (source);
+      MetaSelectionSource *selection_source;
+      GList *mimetypes;
+
       meta_wayland_data_source_set_seat (source, seat);
       g_object_weak_ref (G_OBJECT (source),
                          selection_data_source_destroyed,
                          data_device);
+
+      mimetypes = copy_string_array_to_list (meta_wayland_data_source_get_mime_types (source));
+      selection_source = meta_selection_source_wayland_new (source_wayland->resource,
+                                                            mimetypes,
+                                                            wl_data_source_send_send,
+                                                            wl_data_source_send_cancelled);
+      g_list_free_full (mimetypes, g_free);
+
+      set_selection_source (data_device, META_SELECTION_CLIPBOARD,
+                            selection_source);
+    }
+  else
+    {
+      unset_selection_source (data_device, META_SELECTION_CLIPBOARD);
     }
 
   wl_signal_emit (&data_device->selection_ownership_signal, source);
@@ -1661,6 +1760,7 @@ primary_source_destroyed (gpointer  data,
     }
 
   wl_signal_emit (&data_device->primary_ownership_signal, NULL);
+  unset_selection_source (data_device, META_SELECTION_PRIMARY);
 }
 
 void
@@ -1669,7 +1769,7 @@ meta_wayland_data_device_set_primary (MetaWaylandDataDevice *data_device,
                                       guint32                serial)
 {
   MetaWaylandSeat *seat = wl_container_of (data_device, seat, data_device);
-  struct wl_resource *data_device_resource, *offer;
+  struct wl_resource *data_device_resource;
   struct wl_client *focus_client;
 
   if (META_IS_WAYLAND_DATA_SOURCE_PRIMARY (source))
@@ -1704,25 +1804,35 @@ meta_wayland_data_device_set_primary (MetaWaylandDataDevice *data_device,
       data_device_resource = wl_resource_find_for_client (&data_device->primary_resource_list, focus_client);
       if (data_device_resource)
         {
-          if (data_device->primary_data_source)
-            {
-              offer = meta_wayland_data_source_send_primary_offer (data_device->primary_data_source,
-                                                                   data_device_resource);
-              gtk_primary_selection_device_send_selection (data_device_resource, offer);
-            }
-          else
-            {
-              gtk_primary_selection_device_send_selection (data_device_resource, NULL);
-            }
+          struct wl_resource *offer;
+          offer = create_and_send_primary_offer (data_device, data_device_resource);
+          gtk_primary_selection_device_send_selection (data_device_resource, offer);
         }
     }
 
   if (source)
     {
+      MetaSelectionSource *selection_source;
+      GList *mimetypes;
+
       meta_wayland_data_source_set_seat (source, seat);
       g_object_weak_ref (G_OBJECT (source),
                          primary_source_destroyed,
                          data_device);
+
+      mimetypes = copy_string_array_to_list (meta_wayland_data_source_get_mime_types (source));
+      selection_source = meta_selection_source_wayland_new (META_WAYLAND_DATA_SOURCE_PRIMARY (source)->resource,
+                                                            mimetypes,
+                                                            gtk_primary_selection_source_send_send,
+                                                            gtk_primary_selection_source_send_cancelled);
+      g_list_free_full (mimetypes, g_free);
+
+      set_selection_source (data_device, META_SELECTION_PRIMARY,
+                            selection_source);
+    }
+  else
+    {
+      unset_selection_source (data_device, META_SELECTION_PRIMARY);
     }
 
   wl_signal_emit (&data_device->primary_ownership_signal, source);
@@ -1767,6 +1877,72 @@ create_data_source (struct wl_client *client,
   meta_wayland_data_source_wayland_new (source_resource);
 }
 
+static void
+owner_changed_cb (MetaSelection         *selection,
+                  MetaSelectionType      selection_type,
+                  MetaSelectionSource   *new_owner,
+                  MetaWaylandDataDevice *data_device)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaWaylandSeat *seat = compositor->seat;
+  struct wl_resource *data_device_resource;
+  struct wl_client *focus_client;
+
+  focus_client = meta_wayland_keyboard_get_focus_client (seat->keyboard);
+  if (!focus_client)
+    return;
+
+  if (selection_type == META_SELECTION_PRIMARY)
+    {
+      data_device_resource =
+        wl_resource_find_for_client (&data_device->primary_resource_list,
+                                     focus_client);
+      if (data_device_resource)
+        {
+          struct wl_resource *offer = NULL;
+
+          if (new_owner)
+            {
+              offer = create_and_send_primary_offer (data_device,
+                                                     data_device_resource);
+            }
+
+          gtk_primary_selection_device_send_selection (data_device_resource,
+                                                       offer);
+        }
+    }
+  else if (selection_type == META_SELECTION_CLIPBOARD)
+    {
+      data_device_resource =
+        wl_resource_find_for_client (&data_device->resource_list, focus_client);
+
+      if (data_device_resource)
+        {
+          struct wl_resource *offer = NULL;
+
+          if (new_owner)
+            {
+              offer = create_and_send_clipboard_offer (data_device,
+                                                       data_device_resource);
+            }
+
+          wl_data_device_send_selection (data_device_resource, offer);
+        }
+    }
+}
+
+static void
+ensure_owners_changed_handler_connected (MetaWaylandDataDevice *data_device)
+{
+  if (data_device->selection_owner_signal_id != 0)
+    return;
+
+  data_device->selection_owner_signal_id =
+    g_signal_connect (meta_display_get_selection (meta_get_display ()),
+                      "owner-changed",
+                      G_CALLBACK (owner_changed_cb), data_device);
+}
+
 static void
 get_data_device (struct wl_client *client,
                  struct wl_resource *manager_resource,
@@ -1778,6 +1954,8 @@ get_data_device (struct wl_client *client,
   cr = wl_resource_create (client, &wl_data_device_interface, wl_resource_get_version (manager_resource), id);
   wl_resource_set_implementation (cr, &data_device_interface, &seat->data_device, unbind_resource);
   wl_list_insert (&seat->data_device.resource_list, wl_resource_get_link (cr));
+
+  ensure_owners_changed_handler_connected (&seat->data_device);
 }
 
 static const struct wl_data_device_manager_interface manager_interface = {
@@ -1822,6 +2000,8 @@ primary_device_manager_get_device (struct wl_client   *client,
   wl_resource_set_implementation (cr, &primary_device_interface,
                                   &seat->data_device, unbind_resource);
   wl_list_insert (&seat->data_device.primary_resource_list, wl_resource_get_link (cr));
+
+  ensure_owners_changed_handler_connected (&seat->data_device);
 }
 
 static const struct gtk_primary_selection_device_manager_interface primary_manager_interface = {
@@ -1877,13 +2057,76 @@ meta_wayland_data_device_init (MetaWaylandDataDevice *data_device)
   wl_signal_init (&data_device->dnd_ownership_signal);
 }
 
+static struct wl_resource *
+create_and_send_clipboard_offer (MetaWaylandDataDevice *data_device,
+                                 struct wl_resource    *target)
+{
+  MetaWaylandDataOffer *offer;
+  MetaDisplay *display = meta_get_display ();
+  GList *mimetypes, *l;
+
+  mimetypes = meta_selection_get_mimetypes (meta_display_get_selection (display),
+                                            META_SELECTION_CLIPBOARD);
+  if (!mimetypes)
+    return NULL;
+
+  offer = g_slice_new0 (MetaWaylandDataOffer);
+  offer->resource = wl_resource_create (wl_resource_get_client (target),
+                                        &wl_data_offer_interface,
+                                        wl_resource_get_version (target), 0);
+  wl_resource_set_implementation (offer->resource,
+                                  &data_offer_interface,
+                                  offer,
+                                  destroy_data_offer);
+
+  wl_data_device_send_data_offer (target, offer->resource);
+
+  for (l = mimetypes; l; l = l->next)
+    wl_data_offer_send_offer (offer->resource, l->data);
+
+  g_list_free_full (mimetypes, g_free);
+
+  return offer->resource;
+}
+
+static struct wl_resource *
+create_and_send_primary_offer (MetaWaylandDataDevice *data_device,
+                               struct wl_resource    *target)
+{
+  MetaWaylandDataOffer *offer;
+  MetaDisplay *display = meta_get_display ();
+  GList *mimetypes, *l;
+
+  mimetypes = meta_selection_get_mimetypes (meta_display_get_selection (display),
+                                            META_SELECTION_PRIMARY);
+  if (!mimetypes)
+    return NULL;
+
+  offer = g_slice_new0 (MetaWaylandDataOffer);
+  offer->resource = wl_resource_create (wl_resource_get_client (target),
+                                        &gtk_primary_selection_offer_interface,
+                                        wl_resource_get_version (target), 0);
+  wl_resource_set_implementation (offer->resource,
+                                  &primary_offer_interface,
+                                  offer,
+                                  destroy_primary_offer);
+
+  gtk_primary_selection_device_send_data_offer (target, offer->resource);
+
+  for (l = mimetypes; l; l = l->next)
+    gtk_primary_selection_offer_send_offer (offer->resource, l->data);
+
+  g_list_free_full (mimetypes, g_free);
+
+  return offer->resource;
+}
+
 void
 meta_wayland_data_device_set_keyboard_focus (MetaWaylandDataDevice *data_device)
 {
   MetaWaylandSeat *seat = wl_container_of (data_device, seat, data_device);
   struct wl_client *focus_client;
-  struct wl_resource *data_device_resource, *offer;
-  MetaWaylandDataSource *source;
+  struct wl_resource *data_device_resource;
 
   focus_client = meta_wayland_keyboard_get_focus_client (seat->keyboard);
 
@@ -1898,31 +2141,17 @@ meta_wayland_data_device_set_keyboard_focus (MetaWaylandDataDevice *data_device)
   data_device_resource = wl_resource_find_for_client (&data_device->resource_list, focus_client);
   if (data_device_resource)
     {
-      source = data_device->selection_data_source;
-      if (source)
-        {
-          offer = meta_wayland_data_source_send_offer (source, data_device_resource);
-          wl_data_device_send_selection (data_device_resource, offer);
-        }
-      else
-        {
-          wl_data_device_send_selection (data_device_resource, NULL);
-        }
+      struct wl_resource *offer;
+      offer = create_and_send_clipboard_offer (data_device, data_device_resource);
+      wl_data_device_send_selection (data_device_resource, offer);
     }
 
   data_device_resource = wl_resource_find_for_client (&data_device->primary_resource_list, focus_client);
   if (data_device_resource)
     {
-      source = data_device->primary_data_source;
-      if (source)
-        {
-          offer = meta_wayland_data_source_send_primary_offer (source, data_device_resource);
-          gtk_primary_selection_device_send_selection (data_device_resource, offer);
-        }
-      else
-        {
-          gtk_primary_selection_device_send_selection (data_device_resource, NULL);
-        }
+      struct wl_resource *offer;
+      offer = create_and_send_primary_offer (data_device, data_device_resource);
+      gtk_primary_selection_device_send_selection (data_device_resource, offer);
     }
 }
 
diff --git a/src/wayland/meta-wayland-data-device.h b/src/wayland/meta-wayland-data-device.h
index c63c65033d2c634554be63eb81d69ef24a035818..729baacd90c165b557f6b61441132b7e4675ad5d 100644
--- a/src/wayland/meta-wayland-data-device.h
+++ b/src/wayland/meta-wayland-data-device.h
@@ -27,6 +27,7 @@
 #include <wayland-server.h>
 
 #include "clutter/clutter.h"
+#include "meta/meta-selection-source.h"
 #include "wayland/meta-wayland-types.h"
 
 typedef struct _MetaWaylandDragGrab MetaWaylandDragGrab;
@@ -69,6 +70,10 @@ struct _MetaWaylandDataDevice
   struct wl_signal selection_ownership_signal;
   struct wl_signal dnd_ownership_signal;
   struct wl_signal primary_ownership_signal;
+
+  guint selection_owner_signal_id;
+
+  MetaSelectionSource *owners[META_N_SELECTION_TYPES];
 };
 
 void meta_wayland_data_device_manager_init (MetaWaylandCompositor *compositor);
diff --git a/src/wayland/meta-wayland-private.h b/src/wayland/meta-wayland-private.h
index 07a71f82b1a9a915206dec48a60ace3519dada4d..31a7fc74867152d5dd4053bf84a0ccfa9e1eaa80 100644
--- a/src/wayland/meta-wayland-private.h
+++ b/src/wayland/meta-wayland-private.h
@@ -33,7 +33,7 @@
 #include "wayland/meta-wayland-versions.h"
 #include "wayland/meta-wayland.h"
 
-typedef struct _MetaXWaylandSelection MetaXWaylandSelection;
+typedef struct _MetaXWaylandDnd MetaXWaylandDnd;
 
 typedef struct
 {
@@ -56,7 +56,7 @@ typedef struct
   GSubprocess *proc;
   GMainLoop *init_loop;
 
-  MetaXWaylandSelection *selection_data;
+  MetaXWaylandDnd *dnd;
 } MetaXWaylandManager;
 
 struct _MetaWaylandCompositor
diff --git a/src/wayland/meta-xwayland-selection-private.h b/src/wayland/meta-xwayland-dnd-private.h
similarity index 100%
rename from src/wayland/meta-xwayland-selection-private.h
rename to src/wayland/meta-xwayland-dnd-private.h
diff --git a/src/wayland/meta-xwayland-dnd.c b/src/wayland/meta-xwayland-dnd.c
new file mode 100644
index 0000000000000000000000000000000000000000..15f23fbdac47d62a50e31111e23d25390e3d6a6e
--- /dev/null
+++ b/src/wayland/meta-xwayland-dnd.c
@@ -0,0 +1,948 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* The file is loosely based on xwayland/selection.c from Weston */
+
+#include "config.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <glib-unix.h>
+#include <gio/gunixoutputstream.h>
+#include <gio/gunixinputstream.h>
+#include <gdk/gdkx.h>
+#include <X11/Xatom.h>
+#include <X11/extensions/Xfixes.h>
+
+#include "meta/meta-x11-errors.h"
+#include "wayland/meta-wayland-data-device.h"
+#include "wayland/meta-xwayland-private.h"
+#include "wayland/meta-xwayland-dnd-private.h"
+#include "wayland/meta-xwayland.h"
+#include "x11/meta-x11-display-private.h"
+
+#define INCR_CHUNK_SIZE (128 * 1024)
+#define XDND_VERSION 5
+
+struct _MetaWaylandDataSourceXWayland
+{
+  MetaWaylandDataSource parent;
+  MetaXWaylandDnd *dnd;
+  gboolean has_utf8_string_atom;
+};
+
+struct _MetaXWaylandDnd
+{
+  Window owner;
+  Time client_message_timestamp;
+  MetaWaylandDataSource *source; /* owned by MetaWaylandDataDevice */
+  MetaWaylandSurface *focus_surface;
+  Window dnd_window; /* Mutter-internal window, acts as peer on wayland drop sites */
+  Window dnd_dest; /* X11 drag dest window */
+  guint32 last_motion_time;
+};
+
+enum
+{
+  ATOM_DND_SELECTION,
+  ATOM_DND_AWARE,
+  ATOM_DND_STATUS,
+  ATOM_DND_POSITION,
+  ATOM_DND_ENTER,
+  ATOM_DND_LEAVE,
+  ATOM_DND_DROP,
+  ATOM_DND_FINISHED,
+  ATOM_DND_PROXY,
+  ATOM_DND_TYPE_LIST,
+  ATOM_DND_ACTION_MOVE,
+  ATOM_DND_ACTION_COPY,
+  ATOM_DND_ACTION_ASK,
+  ATOM_DND_ACTION_PRIVATE,
+  N_DND_ATOMS
+};
+
+/* Matches order in enum above */
+const gchar *atom_names[] = {
+  "XdndSelection",
+  "XdndAware",
+  "XdndStatus",
+  "XdndPosition",
+  "XdndEnter",
+  "XdndLeave",
+  "XdndDrop",
+  "XdndFinished",
+  "XdndProxy",
+  "XdndTypeList",
+  "XdndActionMove",
+  "XdndActionCopy",
+  "XdndActionAsk",
+  "XdndActionPrivate",
+  NULL
+};
+
+Atom xdnd_atoms[N_DND_ATOMS];
+
+G_DEFINE_TYPE (MetaWaylandDataSourceXWayland, meta_wayland_data_source_xwayland,
+               META_TYPE_WAYLAND_DATA_SOURCE);
+
+/* XDND helpers */
+static Atom
+action_to_atom (uint32_t action)
+{
+  if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY)
+    return xdnd_atoms[ATOM_DND_ACTION_COPY];
+  else if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
+    return xdnd_atoms[ATOM_DND_ACTION_MOVE];
+  else if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK)
+    return xdnd_atoms[ATOM_DND_ACTION_ASK];
+  else
+    return None;
+}
+
+static enum wl_data_device_manager_dnd_action
+atom_to_action (Atom atom)
+{
+  if (atom == xdnd_atoms[ATOM_DND_ACTION_COPY] ||
+      atom == xdnd_atoms[ATOM_DND_ACTION_PRIVATE])
+    return WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY;
+  else if (atom == xdnd_atoms[ATOM_DND_ACTION_MOVE])
+    return WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE;
+  else if (atom == xdnd_atoms[ATOM_DND_ACTION_ASK])
+    return WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK;
+  else
+    return WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE;
+}
+
+static void
+xdnd_send_enter (MetaXWaylandDnd *dnd,
+                 Window           dest)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaX11Display *x11_display = meta_get_display ()->x11_display;
+  Display *xdisplay = x11_display->xdisplay;
+  MetaWaylandDataSource *data_source;
+  XEvent xev = { 0 };
+  gchar **p;
+  struct wl_array *source_mime_types;
+
+  data_source = compositor->seat->data_device.dnd_data_source;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = xdnd_atoms[ATOM_DND_ENTER];
+  xev.xclient.format = 32;
+  xev.xclient.window = dest;
+
+  xev.xclient.data.l[0] = x11_display->selection.xwindow;
+  xev.xclient.data.l[1] = XDND_VERSION << 24; /* version */
+  xev.xclient.data.l[2] = xev.xclient.data.l[3] = xev.xclient.data.l[4] = 0;
+
+  source_mime_types = meta_wayland_data_source_get_mime_types (data_source);
+  if (source_mime_types->size <= 3)
+    {
+      /* The mimetype atoms fit in this same message */
+      gint i = 2;
+
+      wl_array_for_each (p, source_mime_types)
+        {
+          xev.xclient.data.l[i++] = gdk_x11_get_xatom_by_name (*p);
+        }
+    }
+  else
+    {
+      /* We have more than 3 mimetypes, we must set up
+       * the mimetype list as a XdndTypeList property.
+       */
+      Atom *atomlist;
+      gint i = 0;
+
+      xev.xclient.data.l[1] |= 1;
+      atomlist = g_new0 (Atom, source_mime_types->size);
+
+      wl_array_for_each (p, source_mime_types)
+        {
+          atomlist[i++] = gdk_x11_get_xatom_by_name (*p);
+        }
+
+      XChangeProperty (xdisplay, x11_display->selection.xwindow,
+                       xdnd_atoms[ATOM_DND_TYPE_LIST],
+                       XA_ATOM, 32, PropModeReplace,
+                       (guchar *) atomlist, i);
+    }
+
+  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
+}
+
+static void
+xdnd_send_leave (MetaXWaylandDnd *dnd,
+                 Window           dest)
+{
+  MetaX11Display *x11_display = meta_get_display ()->x11_display;
+  Display *xdisplay = x11_display->xdisplay;
+  XEvent xev = { 0 };
+
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = xdnd_atoms[ATOM_DND_LEAVE];
+  xev.xclient.format = 32;
+  xev.xclient.window = dest;
+  xev.xclient.data.l[0] = x11_display->selection.xwindow;
+
+  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
+}
+
+static void
+xdnd_send_position (MetaXWaylandDnd *dnd,
+                    Window           dest,
+                    uint32_t         time,
+                    int              x,
+                    int              y)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaWaylandDataSource *source = compositor->seat->data_device.dnd_data_source;
+  MetaX11Display *x11_display = meta_get_display ()->x11_display;
+  Display *xdisplay = x11_display->xdisplay;
+  uint32_t action = 0, user_action, actions;
+  XEvent xev = { 0 };
+
+  user_action = meta_wayland_data_source_get_user_action (source);
+  actions = meta_wayland_data_source_get_actions (source);
+
+  if (user_action & actions)
+    action = user_action;
+  if (!action)
+    action = actions;
+
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = xdnd_atoms[ATOM_DND_POSITION];
+  xev.xclient.format = 32;
+  xev.xclient.window = dest;
+
+  xev.xclient.data.l[0] = x11_display->selection.xwindow;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = (x << 16) | y;
+  xev.xclient.data.l[3] = time;
+  xev.xclient.data.l[4] = action_to_atom (action);
+
+  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
+}
+
+static void
+xdnd_send_drop (MetaXWaylandDnd *dnd,
+                Window           dest,
+                uint32_t         time)
+{
+  MetaX11Display *x11_display = meta_get_display ()->x11_display;
+  Display *xdisplay = x11_display->xdisplay;
+  XEvent xev = { 0 };
+
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = xdnd_atoms[ATOM_DND_DROP];
+  xev.xclient.format = 32;
+  xev.xclient.window = dest;
+
+  xev.xclient.data.l[0] = x11_display->selection.xwindow;
+  xev.xclient.data.l[2] = time;
+
+  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
+}
+
+static void
+xdnd_send_finished (MetaXWaylandDnd *dnd,
+                    Window           dest,
+                    gboolean         accepted)
+{
+  MetaX11Display *x11_display = meta_get_display ()->x11_display;
+  Display *xdisplay = x11_display->xdisplay;
+  MetaWaylandDataSource *source = dnd->source;
+  uint32_t action = 0;
+  XEvent xev = { 0 };
+
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = xdnd_atoms[ATOM_DND_FINISHED];
+  xev.xclient.format = 32;
+  xev.xclient.window = dest;
+
+  xev.xclient.data.l[0] = dnd->dnd_window;
+
+  if (accepted)
+    {
+      action = meta_wayland_data_source_get_current_action (source);
+      xev.xclient.data.l[1] = 1; /* Drop successful */
+      xev.xclient.data.l[2] = action_to_atom (action);
+    }
+
+  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
+}
+
+static void
+xdnd_send_status (MetaXWaylandDnd *dnd,
+                  Window           dest,
+                  uint32_t         action)
+{
+  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  XEvent xev = { 0 };
+
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = xdnd_atoms[ATOM_DND_STATUS];
+  xev.xclient.format = 32;
+  xev.xclient.window = dest;
+
+  xev.xclient.data.l[0] = dnd->dnd_window;
+  xev.xclient.data.l[1] = 1 << 1; /* Bit 2: dest wants XdndPosition messages */
+  xev.xclient.data.l[4] = action_to_atom (action);
+
+  if (xev.xclient.data.l[4])
+    xev.xclient.data.l[1] |= 1 << 0; /* Bit 1: dest accepts the drop */
+
+  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
+}
+
+static void
+meta_xwayland_end_dnd_grab (MetaWaylandDataDevice *data_device)
+{
+  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandManager *manager = &compositor->xwayland_manager;
+  MetaXWaylandDnd *dnd = manager->dnd;
+
+  meta_wayland_data_device_end_drag (data_device);
+
+  XMoveResizeWindow (xdisplay, dnd->dnd_window, -1, -1, 1, 1);
+  XUnmapWindow (xdisplay, dnd->dnd_window);
+}
+
+static void
+transfer_cb (MetaSelection *selection,
+             GAsyncResult  *res,
+             GOutputStream *stream)
+{
+  GError *error = NULL;
+
+  if (!meta_selection_transfer_finish (selection, res, &error))
+    {
+      g_warning ("Could not transfer DnD selection: %s\n", error->message);
+      g_error_free (error);
+    }
+
+  g_output_stream_close (stream, NULL, NULL);
+}
+
+static void
+meta_x11_source_send (MetaWaylandDataSource *source,
+                      const gchar           *mime_type,
+                      gint                   fd)
+{
+  MetaDisplay *display = meta_get_display ();
+  GOutputStream *stream;
+
+  stream = g_unix_output_stream_new (fd, TRUE);
+  meta_selection_transfer_async (meta_display_get_selection (display),
+                                 META_SELECTION_DND,
+                                 mime_type,
+                                 -1,
+                                 stream,
+                                 NULL,
+                                 (GAsyncReadyCallback) transfer_cb,
+                                 stream);
+}
+
+static void
+meta_x11_source_target (MetaWaylandDataSource *source,
+                        const gchar           *mime_type)
+{
+  MetaWaylandDataSourceXWayland *source_xwayland =
+    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
+  MetaXWaylandDnd *dnd = source_xwayland->dnd;
+  uint32_t action = 0;
+
+  if (mime_type)
+    action = meta_wayland_data_source_get_current_action (source);
+
+  xdnd_send_status (dnd, dnd->owner, action);
+}
+
+static void
+meta_x11_source_cancel (MetaWaylandDataSource *source)
+{
+  MetaWaylandDataSourceXWayland *source_xwayland =
+    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
+  MetaXWaylandDnd *dnd = source_xwayland->dnd;
+
+  xdnd_send_finished (dnd, dnd->owner, FALSE);
+}
+
+static void
+meta_x11_source_action (MetaWaylandDataSource *source,
+                        uint32_t               action)
+{
+  MetaWaylandDataSourceXWayland *source_xwayland =
+    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
+  MetaXWaylandDnd *dnd = source_xwayland->dnd;
+
+  if (!meta_wayland_data_source_has_target (source))
+    action = 0;
+
+  xdnd_send_status (dnd, dnd->owner, action);
+}
+
+static void
+meta_x11_source_drop_performed (MetaWaylandDataSource *source)
+{
+}
+
+static void
+meta_x11_source_drag_finished (MetaWaylandDataSource *source)
+{
+  MetaWaylandDataSourceXWayland *source_xwayland =
+    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
+  MetaXWaylandDnd *dnd = source_xwayland->dnd;
+  MetaX11Display *x11_display = meta_get_display ()->x11_display;
+  uint32_t action = meta_wayland_data_source_get_current_action (source);
+
+  if (action == WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
+    {
+      Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+
+      /* Request data deletion on the drag source */
+      XConvertSelection (xdisplay,
+                         xdnd_atoms[ATOM_DND_SELECTION],
+                         gdk_x11_get_xatom_by_name ("DELETE"),
+                         gdk_x11_get_xatom_by_name ("_META_SELECTION"),
+                         x11_display->selection.xwindow,
+                         META_CURRENT_TIME);
+    }
+
+  xdnd_send_finished (dnd, dnd->owner, TRUE);
+}
+
+static void
+meta_wayland_data_source_xwayland_init (MetaWaylandDataSourceXWayland *source_xwayland)
+{
+}
+
+static void
+meta_wayland_data_source_xwayland_class_init (MetaWaylandDataSourceXWaylandClass *klass)
+{
+  MetaWaylandDataSourceClass *data_source_class =
+    META_WAYLAND_DATA_SOURCE_CLASS (klass);
+
+  data_source_class->send = meta_x11_source_send;
+  data_source_class->target = meta_x11_source_target;
+  data_source_class->cancel = meta_x11_source_cancel;
+  data_source_class->action = meta_x11_source_action;
+  data_source_class->drop_performed = meta_x11_source_drop_performed;
+  data_source_class->drag_finished = meta_x11_source_drag_finished;
+}
+
+static MetaWaylandDataSource *
+meta_wayland_data_source_xwayland_new (MetaXWaylandDnd *dnd)
+{
+  MetaWaylandDataSourceXWayland *source_xwayland;
+
+  source_xwayland = g_object_new (META_TYPE_WAYLAND_DATA_SOURCE_XWAYLAND, NULL);
+  source_xwayland->dnd = dnd;
+
+  return META_WAYLAND_DATA_SOURCE (source_xwayland);
+}
+
+static void
+meta_x11_drag_dest_focus_in (MetaWaylandDataDevice *data_device,
+                             MetaWaylandSurface    *surface,
+                             MetaWaylandDataOffer  *offer)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+
+  dnd->dnd_dest = surface->window->xwindow;
+  xdnd_send_enter (dnd, dnd->dnd_dest);
+}
+
+static void
+meta_x11_drag_dest_focus_out (MetaWaylandDataDevice *data_device,
+                              MetaWaylandSurface    *surface)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+
+  xdnd_send_leave (dnd, dnd->dnd_dest);
+  dnd->dnd_dest = None;
+}
+
+static void
+meta_x11_drag_dest_motion (MetaWaylandDataDevice *data_device,
+                           MetaWaylandSurface    *surface,
+                           const ClutterEvent    *event)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+  guint32 time;
+  gfloat x, y;
+
+  time = clutter_event_get_time (event);
+  clutter_event_get_coords (event, &x, &y);
+  xdnd_send_position (dnd, dnd->dnd_dest, time, x, y);
+}
+
+static void
+meta_x11_drag_dest_drop (MetaWaylandDataDevice *data_device,
+                         MetaWaylandSurface    *surface)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+
+  xdnd_send_drop (dnd, dnd->dnd_dest,
+                  meta_display_get_current_time_roundtrip (meta_get_display ()));
+}
+
+static void
+meta_x11_drag_dest_update (MetaWaylandDataDevice *data_device,
+                           MetaWaylandSurface    *surface)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+  MetaWaylandSeat *seat = compositor->seat;
+  ClutterPoint pos;
+
+  clutter_input_device_get_coords (seat->pointer->device, NULL, &pos);
+  xdnd_send_position (dnd, dnd->dnd_dest,
+                      clutter_get_current_event_time (),
+                      pos.x, pos.y);
+}
+
+static const MetaWaylandDragDestFuncs meta_x11_drag_dest_funcs = {
+  meta_x11_drag_dest_focus_in,
+  meta_x11_drag_dest_focus_out,
+  meta_x11_drag_dest_motion,
+  meta_x11_drag_dest_drop,
+  meta_x11_drag_dest_update
+};
+
+const MetaWaylandDragDestFuncs *
+meta_xwayland_selection_get_drag_dest_funcs (void)
+{
+  return &meta_x11_drag_dest_funcs;
+}
+
+static gboolean
+meta_xwayland_data_source_fetch_mimetype_list (MetaWaylandDataSource *source,
+                                               Window                 window,
+                                               Atom                   prop)
+{
+  MetaWaylandDataSourceXWayland *source_xwayland =
+    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
+  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  gulong nitems_ret, bytes_after_ret, i;
+  Atom *atoms, type_ret, utf8_string;
+  int format_ret;
+  struct wl_array *source_mime_types;
+
+  source_mime_types = meta_wayland_data_source_get_mime_types (source);
+  if (source_mime_types->size != 0)
+    return TRUE;
+
+  utf8_string = gdk_x11_get_xatom_by_name ("UTF8_STRING");
+  XGetWindowProperty (xdisplay, window, prop,
+                      0, /* offset */
+                      0x1fffffff, /* length */
+                      True, /* delete */
+                      AnyPropertyType,
+                      &type_ret,
+                      &format_ret,
+                      &nitems_ret,
+                      &bytes_after_ret,
+                      (guchar **) &atoms);
+
+  if (nitems_ret == 0 || type_ret != XA_ATOM)
+    {
+      XFree (atoms);
+      return FALSE;
+    }
+
+  for (i = 0; i < nitems_ret; i++)
+    {
+      const gchar *mime_type;
+
+      if (atoms[i] == utf8_string)
+        {
+          meta_wayland_data_source_add_mime_type (source,
+                                                  "text/plain;charset=utf-8");
+          source_xwayland->has_utf8_string_atom = TRUE;
+        }
+
+      mime_type = gdk_x11_get_xatom_name (atoms[i]);
+      meta_wayland_data_source_add_mime_type (source, mime_type);
+    }
+
+  XFree (atoms);
+
+  return TRUE;
+}
+
+static MetaWaylandSurface *
+pick_drop_surface (MetaWaylandCompositor *compositor,
+                   const ClutterEvent    *event)
+{
+  MetaDisplay *display = meta_get_display ();
+  MetaWindow *focus_window = NULL;
+  ClutterPoint pos;
+
+  clutter_event_get_coords (event, &pos.x, &pos.y);
+  focus_window = meta_stack_get_default_focus_window_at_point (display->stack,
+                                                               NULL, NULL,
+                                                               pos.x, pos.y);
+  return focus_window ? focus_window->surface : NULL;
+}
+
+static void
+repick_drop_surface (MetaWaylandCompositor *compositor,
+                     MetaWaylandDragGrab   *drag_grab,
+                     const ClutterEvent    *event)
+{
+  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+  MetaWaylandSurface *focus = NULL;
+
+  focus = pick_drop_surface (compositor, event);
+  if (dnd->focus_surface == focus)
+    return;
+
+  dnd->focus_surface = focus;
+
+  if (focus &&
+      focus->window->client_type == META_WINDOW_CLIENT_TYPE_WAYLAND)
+    {
+      XMapRaised (xdisplay, dnd->dnd_window);
+      XMoveResizeWindow (xdisplay, dnd->dnd_window,
+                         focus->window->rect.x,
+                         focus->window->rect.y,
+                         focus->window->rect.width,
+                         focus->window->rect.height);
+    }
+  else
+    {
+      XMoveResizeWindow (xdisplay, dnd->dnd_window, -1, -1, 1, 1);
+      XUnmapWindow (xdisplay, dnd->dnd_window);
+    }
+}
+
+static void
+drag_xgrab_focus (MetaWaylandPointerGrab *grab,
+                  MetaWaylandSurface     *surface)
+{
+  /* Do not update the focus here. First, the surface may perfectly
+   * be the X11 source DnD icon window's, so we can only be fooled
+   * here. Second, delaying focus handling to XdndEnter/Leave
+   * makes us do the negotiation orderly on the X11 side.
+   */
+}
+
+static void
+drag_xgrab_motion (MetaWaylandPointerGrab *grab,
+                   const ClutterEvent     *event)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+  MetaWaylandSeat *seat = compositor->seat;
+
+  repick_drop_surface (compositor,
+                       (MetaWaylandDragGrab *) grab,
+                       event);
+
+  dnd->last_motion_time = clutter_event_get_time (event);
+  meta_wayland_pointer_send_motion (seat->pointer, event);
+}
+
+static void
+drag_xgrab_button (MetaWaylandPointerGrab *grab,
+                   const ClutterEvent     *event)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaWaylandSeat *seat = compositor->seat;
+  MetaWaylandDataSource *data_source;
+
+  meta_wayland_pointer_send_button (seat->pointer, event);
+  data_source = compositor->seat->data_device.dnd_data_source;
+
+  if (seat->pointer->button_count == 0 &&
+      (!meta_wayland_drag_grab_get_focus ((MetaWaylandDragGrab *) grab) ||
+       meta_wayland_data_source_get_current_action (data_source) ==
+       WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE))
+    meta_xwayland_end_dnd_grab (&seat->data_device);
+}
+
+static const MetaWaylandPointerGrabInterface drag_xgrab_interface = {
+  drag_xgrab_focus,
+  drag_xgrab_motion,
+  drag_xgrab_button,
+};
+
+static gboolean
+meta_xwayland_dnd_handle_client_message (MetaWaylandCompositor *compositor,
+                                         XEvent                *xevent)
+{
+  XClientMessageEvent *event = (XClientMessageEvent *) xevent;
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+  MetaWaylandSeat *seat = compositor->seat;
+  MetaX11Display *x11_display = meta_get_display ()->x11_display;
+
+  /* Source side messages */
+  if (event->window == x11_display->selection.xwindow)
+    {
+      MetaWaylandDataSource *data_source;
+      uint32_t action = 0;
+
+      data_source = compositor->seat->data_device.dnd_data_source;
+
+      if (!data_source)
+        return FALSE;
+
+      if (event->message_type == xdnd_atoms[ATOM_DND_STATUS])
+        {
+          /* The first bit in data.l[1] is set if the drag was accepted */
+          meta_wayland_data_source_set_has_target (data_source,
+                                                   (event->data.l[1] & 1) != 0);
+
+          /* data.l[4] contains the action atom */
+          if (event->data.l[4])
+            action = atom_to_action ((Atom) event->data.l[4]);
+
+          meta_wayland_data_source_set_current_action (data_source, action);
+          return TRUE;
+        }
+      else if (event->message_type == xdnd_atoms[ATOM_DND_FINISHED])
+        {
+          /* Reject messages mid-grab */
+          if (compositor->seat->data_device.current_grab)
+            return FALSE;
+
+          meta_wayland_data_source_notify_finish (data_source);
+          return TRUE;
+        }
+    }
+  /* Dest side messages */
+  else if (dnd->source &&
+           compositor->seat->data_device.current_grab &&
+           (Window) event->data.l[0] == dnd->owner)
+    {
+      MetaWaylandDragGrab *drag_grab = compositor->seat->data_device.current_grab;
+      MetaWaylandSurface *drag_focus = meta_wayland_drag_grab_get_focus (drag_grab);
+
+      if (!drag_focus &&
+          event->message_type != xdnd_atoms[ATOM_DND_ENTER])
+        return FALSE;
+
+      if (event->message_type == xdnd_atoms[ATOM_DND_ENTER])
+        {
+          /* Bit 1 in data.l[1] determines whether there's 3 or less mimetype
+           * atoms (and are thus contained in this same message), or whether
+           * there's more than 3 and we need to check the XdndTypeList property
+           * for the full list.
+           */
+          if (!(event->data.l[1] & 1))
+            {
+              /* Mimetypes are contained in this message */
+              const gchar *mimetype;
+              gint i;
+              struct wl_array *source_mime_types;
+
+              /* We only need to fetch once */
+              source_mime_types =
+                meta_wayland_data_source_get_mime_types (dnd->source);
+              if (source_mime_types->size == 0)
+                {
+                  for (i = 2; i <= 4; i++)
+                    {
+                      if (event->data.l[i] == None)
+                        break;
+
+                      mimetype = gdk_x11_get_xatom_name (event->data.l[i]);
+                      meta_wayland_data_source_add_mime_type (dnd->source,
+                                                              mimetype);
+                    }
+                }
+            }
+          else
+            {
+              /* Fetch mimetypes from type list */
+              meta_xwayland_data_source_fetch_mimetype_list (dnd->source,
+                                                             event->data.l[0],
+                                                             xdnd_atoms[ATOM_DND_TYPE_LIST]);
+            }
+
+          meta_wayland_drag_grab_set_focus (drag_grab, dnd->focus_surface);
+          return TRUE;
+        }
+      else if (event->message_type == xdnd_atoms[ATOM_DND_POSITION])
+        {
+          ClutterEvent *motion;
+          ClutterPoint pos;
+          uint32_t action = 0;
+
+          dnd->client_message_timestamp = event->data.l[3];
+
+          motion = clutter_event_new (CLUTTER_MOTION);
+          clutter_input_device_get_coords (seat->pointer->device, NULL, &pos);
+          clutter_event_set_coords (motion, pos.x, pos.y);
+          clutter_event_set_device (motion, seat->pointer->device);
+          clutter_event_set_source_device (motion, seat->pointer->device);
+          clutter_event_set_time (motion, dnd->last_motion_time);
+
+          action = atom_to_action ((Atom) event->data.l[4]);
+          meta_wayland_data_source_set_actions (dnd->source, action);
+
+          meta_wayland_surface_drag_dest_motion (drag_focus, motion);
+          xdnd_send_status (dnd, (Window) event->data.l[0],
+                            meta_wayland_data_source_get_current_action (dnd->source));
+
+          clutter_event_free (motion);
+          return TRUE;
+        }
+      else if (event->message_type == xdnd_atoms[ATOM_DND_LEAVE])
+        {
+          meta_wayland_drag_grab_set_focus (drag_grab, NULL);
+          return TRUE;
+        }
+      else if (event->message_type == xdnd_atoms[ATOM_DND_DROP])
+        {
+          dnd->client_message_timestamp = event->data.l[2];
+          meta_wayland_surface_drag_dest_drop (drag_focus);
+          meta_xwayland_end_dnd_grab (&seat->data_device);
+          return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+static gboolean
+meta_xwayland_dnd_handle_xfixes_selection_notify (MetaWaylandCompositor *compositor,
+                                                  XEvent                *xevent)
+{
+  XFixesSelectionNotifyEvent *event = (XFixesSelectionNotifyEvent *) xevent;
+  MetaXWaylandDnd *dnd = compositor->xwayland_manager.dnd;
+  MetaWaylandDataDevice *data_device = &compositor->seat->data_device;
+  MetaX11Display *x11_display = meta_get_display ()->x11_display;
+  MetaWaylandSurface *focus;
+
+  if (event->selection != xdnd_atoms[ATOM_DND_SELECTION])
+    return FALSE;
+
+  dnd->owner = event->owner;
+  focus = compositor->seat->pointer->focus_surface;
+
+  if (event->owner != None && event->owner != x11_display->selection.xwindow &&
+      focus && meta_xwayland_is_xwayland_surface (focus))
+    {
+      dnd->source = meta_wayland_data_source_xwayland_new (dnd);
+      meta_wayland_data_device_set_dnd_source (&compositor->seat->data_device,
+                                               dnd->source);
+
+      meta_wayland_data_device_start_drag (data_device,
+                                           wl_resource_get_client (focus->resource),
+                                           &drag_xgrab_interface,
+                                           focus, dnd->source,
+                                           NULL);
+    }
+  else if (event->owner == None)
+    {
+      meta_xwayland_end_dnd_grab (data_device);
+    }
+
+  return FALSE;
+}
+
+gboolean
+meta_xwayland_dnd_handle_event (XEvent *xevent)
+{
+  MetaWaylandCompositor *compositor;
+
+  compositor = meta_wayland_compositor_get_default ();
+
+  if (!compositor->xwayland_manager.dnd)
+    return FALSE;
+
+  switch (xevent->type)
+    {
+    case ClientMessage:
+      return meta_xwayland_dnd_handle_client_message (compositor, xevent);
+    default:
+      {
+        MetaX11Display *x11_display = meta_get_display ()->x11_display;
+
+        if (xevent->type - x11_display->xfixes_event_base == XFixesSelectionNotify)
+          return meta_xwayland_dnd_handle_xfixes_selection_notify (compositor, xevent);
+
+        return FALSE;
+      }
+    }
+}
+
+void
+meta_xwayland_init_dnd (void)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandManager *manager = &compositor->xwayland_manager;
+  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  MetaXWaylandDnd *dnd = manager->dnd;
+  XSetWindowAttributes attributes;
+  guint32 i, version = XDND_VERSION;
+
+  g_assert (manager->dnd == NULL);
+
+  manager->dnd = dnd = g_slice_new0 (MetaXWaylandDnd);
+
+  for (i = 0; i < N_DND_ATOMS; i++)
+    xdnd_atoms[i] = gdk_x11_get_xatom_by_name (atom_names[i]);
+
+  attributes.event_mask = PropertyChangeMask | SubstructureNotifyMask;
+  attributes.override_redirect = True;
+
+  dnd->dnd_window = XCreateWindow (xdisplay,
+                                   gdk_x11_window_get_xid (gdk_get_default_root_window ()),
+                                   -1, -1, 1, 1,
+                                   0, /* border width */
+                                   0, /* depth */
+                                   InputOnly, /* class */
+                                   CopyFromParent, /* visual */
+                                   CWEventMask | CWOverrideRedirect,
+                                   &attributes);
+  XChangeProperty (xdisplay, dnd->dnd_window,
+                   xdnd_atoms[ATOM_DND_AWARE],
+                   XA_ATOM, 32, PropModeReplace,
+                   (guchar*) &version, 1);
+}
+
+void
+meta_xwayland_shutdown_dnd (void)
+{
+  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
+  MetaXWaylandManager *manager = &compositor->xwayland_manager;
+  MetaXWaylandDnd *dnd = manager->dnd;
+
+  g_assert (dnd != NULL);
+
+  XDestroyWindow (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                  dnd->dnd_window);
+  dnd->dnd_window = None;
+
+  g_slice_free (MetaXWaylandDnd, dnd);
+  manager->dnd = NULL;
+}
diff --git a/src/wayland/meta-xwayland-private.h b/src/wayland/meta-xwayland-private.h
index 38874eda3f4152e8084d0c517c7f856b4de5cf1e..9a109da661f5ab7a8e72ad5b3d1967121a513ece 100644
--- a/src/wayland/meta-xwayland-private.h
+++ b/src/wayland/meta-xwayland-private.h
@@ -35,9 +35,9 @@ void
 meta_xwayland_stop (MetaXWaylandManager *manager);
 
 /* wl_data_device/X11 selection interoperation */
-void     meta_xwayland_init_selection         (void);
-void     meta_xwayland_shutdown_selection     (void);
-gboolean meta_xwayland_selection_handle_event (XEvent *xevent);
+void     meta_xwayland_init_dnd         (void);
+void     meta_xwayland_shutdown_dnd     (void);
+gboolean meta_xwayland_dnd_handle_event (XEvent *xevent);
 
 const MetaWaylandDragDestFuncs * meta_xwayland_selection_get_drag_dest_funcs (void);
 
diff --git a/src/wayland/meta-xwayland-selection.c b/src/wayland/meta-xwayland-selection.c
deleted file mode 100644
index 808f9133395bae17e95ca7aed7e7623162bc1279..0000000000000000000000000000000000000000
--- a/src/wayland/meta-xwayland-selection.c
+++ /dev/null
@@ -1,1797 +0,0 @@
-/*
- * Copyright © 2012 Intel Corporation
- *
- * Permission to use, copy, modify, distribute, and sell this software and
- * its documentation for any purpose is hereby granted without fee, provided
- * that the above copyright notice appear in all copies and that both that
- * copyright notice and this permission notice appear in supporting
- * documentation, and that the name of the copyright holders not be used in
- * advertising or publicity pertaining to distribution of the software
- * without specific, written prior permission.  The copyright holders make
- * no representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
- * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
- * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
- * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-/* The file is loosely based on xwayland/selection.c from Weston */
-
-#include "config.h"
-
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
-#include <glib-unix.h>
-#include <gio/gunixoutputstream.h>
-#include <gio/gunixinputstream.h>
-#include <gdk/gdkx.h>
-#include <X11/Xatom.h>
-#include <X11/extensions/Xfixes.h>
-
-#include "meta/meta-x11-errors.h"
-#include "wayland/meta-wayland-data-device.h"
-#include "wayland/meta-xwayland-private.h"
-#include "wayland/meta-xwayland-selection-private.h"
-#include "wayland/meta-xwayland.h"
-#include "x11/meta-x11-display-private.h"
-
-#define INCR_CHUNK_SIZE (128 * 1024)
-#define XDND_VERSION 5
-
-typedef struct {
-  MetaXWaylandSelection *selection_data;
-  GInputStream *stream;
-  GCancellable *cancellable;
-  MetaWindow *window;
-  XSelectionRequestEvent request_event;
-  guchar buffer[INCR_CHUNK_SIZE];
-  gsize buffer_len;
-  guint incr : 1;
-} WaylandSelectionData;
-
-typedef struct {
-  MetaXWaylandSelection *selection_data;
-  GOutputStream *stream;
-  GCancellable *cancellable;
-  gchar *mime_type;
-  guint incr : 1;
-} X11SelectionData;
-
-typedef struct {
-  Atom selection_atom;
-  Window window;
-  Window owner;
-  Time timestamp;
-  Time client_message_timestamp;
-  MetaWaylandDataSource *source; /* owned by MetaWaylandDataDevice */
-  WaylandSelectionData *wayland_selection;
-  X11SelectionData *x11_selection;
-
-  struct wl_listener ownership_listener;
-} MetaSelectionBridge;
-
-typedef struct {
-  MetaSelectionBridge selection;
-  MetaWaylandSurface *focus_surface;
-  Window dnd_window; /* Mutter-internal window, acts as peer on wayland drop sites */
-  Window dnd_dest; /* X11 drag dest window */
-  guint32 last_motion_time;
-} MetaDndBridge;
-
-struct _MetaWaylandDataSourceXWayland
-{
-  MetaWaylandDataSource parent;
-
-  MetaSelectionBridge *selection;
-  guint has_utf8_string_atom : 1;
-};
-
-struct _MetaXWaylandSelection {
-  MetaSelectionBridge clipboard;
-  MetaSelectionBridge primary;
-  MetaDndBridge dnd;
-};
-
-enum
-{
-  ATOM_DND_SELECTION,
-  ATOM_DND_AWARE,
-  ATOM_DND_STATUS,
-  ATOM_DND_POSITION,
-  ATOM_DND_ENTER,
-  ATOM_DND_LEAVE,
-  ATOM_DND_DROP,
-  ATOM_DND_FINISHED,
-  ATOM_DND_PROXY,
-  ATOM_DND_TYPE_LIST,
-  ATOM_DND_ACTION_MOVE,
-  ATOM_DND_ACTION_COPY,
-  ATOM_DND_ACTION_ASK,
-  ATOM_DND_ACTION_PRIVATE,
-  N_DND_ATOMS
-};
-
-/* Matches order in enum above */
-const gchar *atom_names[] = {
-  "XdndSelection",
-  "XdndAware",
-  "XdndStatus",
-  "XdndPosition",
-  "XdndEnter",
-  "XdndLeave",
-  "XdndDrop",
-  "XdndFinished",
-  "XdndProxy",
-  "XdndTypeList",
-  "XdndActionMove",
-  "XdndActionCopy",
-  "XdndActionAsk",
-  "XdndActionPrivate",
-  NULL
-};
-
-Atom xdnd_atoms[N_DND_ATOMS];
-
-G_DEFINE_TYPE (MetaWaylandDataSourceXWayland, meta_wayland_data_source_xwayland,
-               META_TYPE_WAYLAND_DATA_SOURCE);
-
-/* XDND helpers */
-static Atom
-action_to_atom (uint32_t action)
-{
-  if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY)
-    return xdnd_atoms[ATOM_DND_ACTION_COPY];
-  else if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
-    return xdnd_atoms[ATOM_DND_ACTION_MOVE];
-  else if (action & WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK)
-    return xdnd_atoms[ATOM_DND_ACTION_ASK];
-  else
-    return None;
-}
-
-static enum wl_data_device_manager_dnd_action
-atom_to_action (Atom atom)
-{
-  if (atom == xdnd_atoms[ATOM_DND_ACTION_COPY] ||
-      atom == xdnd_atoms[ATOM_DND_ACTION_PRIVATE])
-    return WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY;
-  else if (atom == xdnd_atoms[ATOM_DND_ACTION_MOVE])
-    return WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE;
-  else if (atom == xdnd_atoms[ATOM_DND_ACTION_ASK])
-    return WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK;
-  else
-    return WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE;
-}
-
-static void
-xdnd_send_enter (MetaXWaylandSelection *selection_data,
-                 Window                 dest)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaSelectionBridge *selection = &selection_data->dnd.selection;
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaWaylandDataSource *data_source;
-  XEvent xev = { 0 };
-  gchar **p;
-  struct wl_array *source_mime_types;
-
-  data_source = compositor->seat->data_device.dnd_data_source;
-  xev.xclient.type = ClientMessage;
-  xev.xclient.message_type = xdnd_atoms[ATOM_DND_ENTER];
-  xev.xclient.format = 32;
-  xev.xclient.window = dest;
-
-  xev.xclient.data.l[0] = selection->window;
-  xev.xclient.data.l[1] = XDND_VERSION << 24; /* version */
-  xev.xclient.data.l[2] = xev.xclient.data.l[3] = xev.xclient.data.l[4] = 0;
-
-  source_mime_types = meta_wayland_data_source_get_mime_types (data_source);
-  if (source_mime_types->size <= 3)
-    {
-      /* The mimetype atoms fit in this same message */
-      gint i = 2;
-
-      wl_array_for_each (p, source_mime_types)
-        {
-          xev.xclient.data.l[i++] = gdk_x11_get_xatom_by_name (*p);
-        }
-    }
-  else
-    {
-      /* We have more than 3 mimetypes, we must set up
-       * the mimetype list as a XdndTypeList property.
-       */
-      Atom *atomlist;
-      gint i = 0;
-
-      xev.xclient.data.l[1] |= 1;
-      atomlist = g_new0 (Atom, source_mime_types->size);
-
-      wl_array_for_each (p, source_mime_types)
-        {
-          atomlist[i++] = gdk_x11_get_xatom_by_name (*p);
-        }
-
-      XChangeProperty (xdisplay, selection->window,
-                       xdnd_atoms[ATOM_DND_TYPE_LIST],
-                       XA_ATOM, 32, PropModeReplace,
-                       (guchar *) atomlist, i);
-    }
-
-  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
-}
-
-static void
-xdnd_send_leave (MetaXWaylandSelection *selection_data,
-                 Window                 dest)
-{
-  MetaSelectionBridge *selection = &selection_data->dnd.selection;
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  XEvent xev = { 0 };
-
-  xev.xclient.type = ClientMessage;
-  xev.xclient.message_type = xdnd_atoms[ATOM_DND_LEAVE];
-  xev.xclient.format = 32;
-  xev.xclient.window = dest;
-  xev.xclient.data.l[0] = selection->window;
-
-  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
-}
-
-static void
-xdnd_send_position (MetaXWaylandSelection *selection_data,
-                    Window                 dest,
-                    uint32_t               time,
-                    int                    x,
-                    int                    y)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaSelectionBridge *selection = &selection_data->dnd.selection;
-  MetaWaylandDataSource *source = compositor->seat->data_device.dnd_data_source;
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  uint32_t action = 0, user_action, actions;
-  XEvent xev = { 0 };
-
-  user_action = meta_wayland_data_source_get_user_action (source);
-  actions = meta_wayland_data_source_get_actions (source);
-
-  if (user_action & actions)
-    action = user_action;
-  if (!action)
-    action = actions;
-
-  xev.xclient.type = ClientMessage;
-  xev.xclient.message_type = xdnd_atoms[ATOM_DND_POSITION];
-  xev.xclient.format = 32;
-  xev.xclient.window = dest;
-
-  xev.xclient.data.l[0] = selection->window;
-  xev.xclient.data.l[1] = 0;
-  xev.xclient.data.l[2] = (x << 16) | y;
-  xev.xclient.data.l[3] = time;
-  xev.xclient.data.l[4] = action_to_atom (action);
-
-  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
-}
-
-static void
-xdnd_send_drop (MetaXWaylandSelection *selection_data,
-                Window                 dest,
-                uint32_t               time)
-{
-  MetaSelectionBridge *selection = &selection_data->dnd.selection;
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  XEvent xev = { 0 };
-
-  xev.xclient.type = ClientMessage;
-  xev.xclient.message_type = xdnd_atoms[ATOM_DND_DROP];
-  xev.xclient.format = 32;
-  xev.xclient.window = dest;
-
-  xev.xclient.data.l[0] = selection->window;
-  xev.xclient.data.l[2] = time;
-
-  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
-}
-
-static void
-xdnd_send_finished (MetaXWaylandSelection *selection_data,
-                    Window                 dest,
-                    gboolean               accepted)
-{
-  MetaDndBridge *selection = &selection_data->dnd;
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaWaylandDataSource *source = selection_data->dnd.selection.source;
-  uint32_t action = 0;
-  XEvent xev = { 0 };
-
-  xev.xclient.type = ClientMessage;
-  xev.xclient.message_type = xdnd_atoms[ATOM_DND_FINISHED];
-  xev.xclient.format = 32;
-  xev.xclient.window = dest;
-
-  xev.xclient.data.l[0] = selection->dnd_window;
-
-  if (accepted)
-    {
-      action = meta_wayland_data_source_get_current_action (source);
-      xev.xclient.data.l[1] = 1; /* Drop successful */
-      xev.xclient.data.l[2] = action_to_atom (action);
-    }
-
-  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
-}
-
-static void
-xdnd_send_status (MetaXWaylandSelection *selection_data,
-                  Window                 dest,
-                  uint32_t               action)
-{
-  MetaDndBridge *selection = &selection_data->dnd;
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  XEvent xev = { 0 };
-
-  xev.xclient.type = ClientMessage;
-  xev.xclient.message_type = xdnd_atoms[ATOM_DND_STATUS];
-  xev.xclient.format = 32;
-  xev.xclient.window = dest;
-
-  xev.xclient.data.l[0] = selection->dnd_window;
-  xev.xclient.data.l[1] = 1 << 1; /* Bit 2: dest wants XdndPosition messages */
-  xev.xclient.data.l[4] = action_to_atom (action);
-
-  if (xev.xclient.data.l[4])
-    xev.xclient.data.l[1] |= 1 << 0; /* Bit 1: dest accepts the drop */
-
-  XSendEvent (xdisplay, dest, False, NoEventMask, &xev);
-}
-
-static void
-meta_xwayland_init_dnd (MetaXWaylandManager *manager)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaDndBridge *dnd = &manager->selection_data->dnd;
-  XSetWindowAttributes attributes;
-  guint32 i, version = XDND_VERSION;
-
-  for (i = 0; i < N_DND_ATOMS; i++)
-    xdnd_atoms[i] = gdk_x11_get_xatom_by_name (atom_names[i]);
-
-  attributes.event_mask = PropertyChangeMask | SubstructureNotifyMask;
-  attributes.override_redirect = True;
-
-  dnd->dnd_window = XCreateWindow (xdisplay,
-                                   gdk_x11_window_get_xid (gdk_get_default_root_window ()),
-                                   -1, -1, 1, 1,
-                                   0, /* border width */
-                                   0, /* depth */
-                                   InputOnly, /* class */
-                                   CopyFromParent, /* visual */
-                                   CWEventMask | CWOverrideRedirect,
-                                   &attributes);
-  XChangeProperty (xdisplay, dnd->dnd_window,
-                   xdnd_atoms[ATOM_DND_AWARE],
-                   XA_ATOM, 32, PropModeReplace,
-                   (guchar*) &version, 1);
-}
-
-static void
-meta_xwayland_shutdown_dnd (MetaXWaylandManager *manager)
-{
-  MetaDndBridge *dnd = &manager->selection_data->dnd;
-
-  XDestroyWindow (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                  dnd->dnd_window);
-  dnd->dnd_window = None;
-}
-
-static void
-meta_xwayland_end_dnd_grab (MetaWaylandDataDevice *data_device)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaXWaylandManager *manager = &compositor->xwayland_manager;
-  MetaDndBridge *dnd = &manager->selection_data->dnd;
-
-  meta_wayland_data_device_end_drag (data_device);
-
-  XMoveResizeWindow (xdisplay, dnd->dnd_window, -1, -1, 1, 1);
-  XUnmapWindow (xdisplay, dnd->dnd_window);
-}
-
-/* X11/Wayland data bridges */
-
-static MetaSelectionBridge *
-atom_to_selection_bridge (MetaWaylandCompositor *compositor,
-                          Atom                   selection_atom)
-{
-  MetaXWaylandSelection *selection_data = compositor->xwayland_manager.selection_data;
-
-  if (selection_atom == selection_data->clipboard.selection_atom)
-    return &selection_data->clipboard;
-  else if (selection_atom == selection_data->primary.selection_atom)
-    return &selection_data->primary;
-  else if (selection_atom == selection_data->dnd.selection.selection_atom)
-    return &selection_data->dnd.selection;
-  else
-    return NULL;
-}
-
-static X11SelectionData *
-x11_selection_data_new (MetaXWaylandSelection *selection_data,
-                        int                    fd,
-                        const char            *mime_type)
-{
-  X11SelectionData *data;
-
-  data = g_slice_new0 (X11SelectionData);
-  data->selection_data = selection_data;
-  data->stream = g_unix_output_stream_new (fd, TRUE);
-  data->cancellable = g_cancellable_new ();
-  data->mime_type = g_strdup (mime_type);
-
-  return data;
-}
-
-static void
-x11_selection_data_free (X11SelectionData *data)
-{
-  g_cancellable_cancel (data->cancellable);
-  g_object_unref (data->cancellable);
-  g_object_unref (data->stream);
-  g_free (data->mime_type);
-  g_slice_free (X11SelectionData, data);
-}
-
-static void
-x11_selection_data_send_finished (MetaSelectionBridge *selection,
-                                  gboolean             success)
-{
-  uint32_t action = meta_wayland_data_source_get_current_action (selection->source);
-
-  if (!selection->x11_selection)
-    return;
-
-  if (success && action == WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
-    {
-      Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-
-      /* Request data deletion on the drag source */
-      XConvertSelection (xdisplay,
-                         selection->selection_atom,
-                         gdk_x11_get_xatom_by_name ("DELETE"),
-                         gdk_x11_get_xatom_by_name ("_META_SELECTION"),
-                         selection->window,
-                         META_CURRENT_TIME);
-    }
-
-  xdnd_send_finished (selection->x11_selection->selection_data,
-                      selection->owner, success);
-}
-
-static void
-x11_selection_data_finish (MetaSelectionBridge *selection,
-                           gboolean             success)
-{
-  if (!selection->x11_selection)
-    return;
-
-  if (selection == &selection->x11_selection->selection_data->dnd.selection)
-    x11_selection_data_send_finished (selection, success);
-
-  g_clear_pointer (&selection->x11_selection,
-                   x11_selection_data_free);
-}
-
-static void
-x11_selection_data_close (X11SelectionData *data)
-{
-  g_output_stream_close (data->stream, data->cancellable, NULL);
-}
-
-static void
-x11_data_write_cb (GObject      *object,
-                   GAsyncResult *res,
-                   gpointer      user_data)
-{
-  MetaSelectionBridge *selection = user_data;
-  X11SelectionData *data = selection->x11_selection;
-  GError *error = NULL;
-  gboolean success = TRUE;
-
-  g_output_stream_write_finish (G_OUTPUT_STREAM (object), res, &error);
-
-  if (error)
-    {
-      if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-        {
-          g_error_free (error);
-          return;
-        }
-
-      g_warning ("Error writing from X11 selection: %s\n", error->message);
-      g_error_free (error);
-      success = FALSE;
-    }
-
-  if (success && data->incr)
-    {
-      Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-      XDeleteProperty (xdisplay, selection->window,
-                       gdk_x11_get_xatom_by_name ("_META_SELECTION"));
-    }
-  else
-    {
-      x11_selection_data_close (selection->x11_selection);
-      x11_selection_data_finish (selection, success);
-    }
-}
-
-static void
-x11_selection_data_write (MetaSelectionBridge *selection,
-                          guchar              *buffer,
-                          gulong               len)
-{
-  X11SelectionData *data = selection->x11_selection;
-
-  g_output_stream_write_async (data->stream, buffer, len,
-                               G_PRIORITY_DEFAULT, data->cancellable,
-                               x11_data_write_cb, selection);
-}
-
-static MetaWaylandDataSource *
-data_device_get_active_source_for_atom (MetaWaylandDataDevice *data_device,
-                                        Atom                   selection_atom)
-{
-  if (selection_atom == gdk_x11_get_xatom_by_name ("CLIPBOARD"))
-    return data_device->selection_data_source;
-  else if (selection_atom == gdk_x11_get_xatom_by_name ("PRIMARY"))
-    return data_device->primary_data_source;
-  else if (selection_atom == xdnd_atoms[ATOM_DND_SELECTION])
-    return data_device->dnd_data_source;
-  else
-    return NULL;
-}
-
-static WaylandSelectionData *
-wayland_selection_data_new (XSelectionRequestEvent *request_event,
-                            MetaWaylandCompositor  *compositor)
-{
-  MetaDisplay *display = meta_get_display ();
-  MetaX11Display *x11_display = display->x11_display;
-  MetaWaylandDataDevice *data_device;
-  MetaWaylandDataSource *wayland_source;
-  MetaSelectionBridge *selection;
-  WaylandSelectionData *data;
-  const gchar *mime_type;
-  GError *error = NULL;
-  int p[2];
-
-  selection = atom_to_selection_bridge (compositor, request_event->selection);
-
-  if (!selection)
-    return NULL;
-
-  if (!g_unix_open_pipe (p, FD_CLOEXEC, &error))
-    {
-      g_critical ("Failed to open pipe: %s\n", error->message);
-      g_error_free (error);
-      return NULL;
-    }
-
-  data_device = &compositor->seat->data_device;
-  mime_type = gdk_x11_get_xatom_name (request_event->target);
-
-  if (!g_unix_set_fd_nonblocking (p[0], TRUE, &error) ||
-      !g_unix_set_fd_nonblocking (p[1], TRUE, &error))
-    {
-      if (error)
-        {
-          g_critical ("Failed to make fds non-blocking: %s\n", error->message);
-          g_error_free (error);
-        }
-
-      close (p[0]);
-      close (p[1]);
-      return NULL;
-    }
-
-  wayland_source = data_device_get_active_source_for_atom (data_device,
-                                                           selection->selection_atom),
-  meta_wayland_data_source_send (wayland_source, mime_type, p[1]);
-
-  data = g_slice_new0 (WaylandSelectionData);
-  data->request_event = *request_event;
-  data->cancellable = g_cancellable_new ();
-  data->stream = g_unix_input_stream_new (p[0], TRUE);
-
-  data->window = meta_x11_display_lookup_x_window (x11_display,
-                                                   data->request_event.requestor);
-
-  /* Do *not* change the event mask on the root window, bugger! */
-  if (!data->window && data->request_event.requestor != x11_display->xroot)
-    {
-      /* Not a managed window, set the PropertyChangeMask
-       * for INCR deletion notifications.
-       */
-      XSelectInput (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                    data->request_event.requestor, PropertyChangeMask);
-    }
-
-  return data;
-}
-
-static void
-reply_selection_request (XSelectionRequestEvent *request_event,
-                         gboolean                accepted)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  XSelectionEvent event;
-
-  memset(&event, 0, sizeof (XSelectionEvent));
-  event.type = SelectionNotify;
-  event.time = request_event->time;
-  event.requestor = request_event->requestor;
-  event.selection = request_event->selection;
-  event.target = request_event->target;
-  event.property = accepted ? request_event->property : None;
-
-  XSendEvent (xdisplay, request_event->requestor,
-              False, NoEventMask, (XEvent *) &event);
-}
-
-static void
-wayland_selection_data_free (WaylandSelectionData *data)
-{
-  MetaDisplay *display = meta_get_display ();
-  MetaX11Display *x11_display = display->x11_display;
-
-  /* Do *not* change the event mask on the root window, bugger! */
-  if (!data->window && data->request_event.requestor != x11_display->xroot)
-    {
-      meta_x11_error_trap_push (x11_display);
-      XSelectInput (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                    data->request_event.requestor, NoEventMask);
-      meta_x11_error_trap_pop (x11_display);
-    }
-
-  g_cancellable_cancel (data->cancellable);
-  g_object_unref (data->cancellable);
-  g_object_unref (data->stream);
-  g_slice_free (WaylandSelectionData, data);
-}
-
-static void
-wayland_selection_update_x11_property (WaylandSelectionData *data)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-
-  XChangeProperty (xdisplay,
-                   data->request_event.requestor,
-                   data->request_event.property,
-                   data->request_event.target,
-                   8, PropModeReplace,
-                   data->buffer, data->buffer_len);
-  data->buffer_len = 0;
-}
-
-static void
-wayland_data_read_cb (GObject      *object,
-                      GAsyncResult *res,
-                      gpointer      user_data)
-{
-  MetaSelectionBridge *selection = user_data;
-  WaylandSelectionData *data = selection->wayland_selection;
-  GError *error = NULL;
-  gsize bytes_read;
-
-  if (!g_input_stream_read_all_finish (G_INPUT_STREAM (object),
-                                       res, &bytes_read, &error))
-    {
-      if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-        {
-          g_error_free (error);
-          return;
-        }
-
-      g_warning ("Error transferring wayland clipboard to X11: %s\n",
-                 error->message);
-      g_error_free (error);
-
-      if (data && data->stream == G_INPUT_STREAM (object))
-        {
-          reply_selection_request (&data->request_event, FALSE);
-          g_clear_pointer (&selection->wayland_selection,
-                           wayland_selection_data_free);
-        }
-
-      return;
-    }
-
-  data->buffer_len = bytes_read;
-
-  if (bytes_read == INCR_CHUNK_SIZE)
-    {
-      if (!data->incr)
-        {
-          Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-          guint32 incr_chunk_size = INCR_CHUNK_SIZE;
-
-          /* Not yet in incr */
-          data->incr = TRUE;
-          XChangeProperty (xdisplay,
-                           data->request_event.requestor,
-                           data->request_event.property,
-                           gdk_x11_get_xatom_by_name ("INCR"),
-                           32, PropModeReplace,
-                           (guchar *) &incr_chunk_size, 1);
-          reply_selection_request (&data->request_event, TRUE);
-        }
-      else
-        wayland_selection_update_x11_property (data);
-    }
-  else
-    {
-      if (!data->incr)
-        {
-          /* Non-incr transfer finished */
-          wayland_selection_update_x11_property (data);
-          reply_selection_request (&data->request_event, TRUE);
-        }
-      else if (data->incr)
-        {
-          /* Incr transfer complete, setting a new property */
-          wayland_selection_update_x11_property (data);
-
-          if (bytes_read > 0)
-            return;
-        }
-
-      g_clear_pointer (&selection->wayland_selection,
-                       wayland_selection_data_free);
-    }
-}
-
-static void
-wayland_selection_data_read (MetaSelectionBridge *selection)
-{
-  WaylandSelectionData *data = selection->wayland_selection;
-
-  g_input_stream_read_all_async (data->stream, data->buffer,
-                                 INCR_CHUNK_SIZE, G_PRIORITY_DEFAULT,
-                                 data->cancellable,
-                                 wayland_data_read_cb, selection);
-}
-
-static void
-meta_xwayland_selection_get_incr_chunk (MetaWaylandCompositor *compositor,
-                                        MetaSelectionBridge   *selection)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  gulong nitems_ret, bytes_after_ret;
-  guchar *prop_ret;
-  int format_ret;
-  Atom type_ret;
-
-  XGetWindowProperty (xdisplay,
-                      selection->window,
-                      gdk_x11_get_xatom_by_name ("_META_SELECTION"),
-                      0, /* offset */
-                      0x1fffffff, /* length */
-                      False, /* delete */
-                      AnyPropertyType,
-                      &type_ret,
-                      &format_ret,
-                      &nitems_ret,
-                      &bytes_after_ret,
-                      &prop_ret);
-
-  if (nitems_ret > 0)
-    {
-      x11_selection_data_write (selection, prop_ret, nitems_ret);
-    }
-  else
-    {
-      /* Transfer has completed */
-      x11_selection_data_close (selection->x11_selection);
-      x11_selection_data_finish (selection, TRUE);
-    }
-
-  XFree (prop_ret);
-}
-
-static void
-meta_x11_source_send (MetaWaylandDataSource *source,
-                      const gchar           *mime_type,
-                      gint                   fd)
-{
-  MetaWaylandDataSourceXWayland *source_xwayland =
-    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaSelectionBridge *selection = source_xwayland->selection;
-  Atom type_atom;
-
-  if (source_xwayland->has_utf8_string_atom &&
-      strcmp (mime_type, "text/plain;charset=utf-8") == 0)
-    type_atom = gdk_x11_get_xatom_by_name ("UTF8_STRING");
-  else
-    type_atom = gdk_x11_get_xatom_by_name (mime_type);
-
-  /* Ensure we close previous transactions */
-  x11_selection_data_finish (selection, FALSE);
-
-  /* Takes ownership of fd */
-  selection->x11_selection =
-    x11_selection_data_new (compositor->xwayland_manager.selection_data,
-                            fd, gdk_x11_get_xatom_name (type_atom));
-
-  XConvertSelection (xdisplay,
-                     selection->selection_atom, type_atom,
-                     gdk_x11_get_xatom_by_name ("_META_SELECTION"),
-                     selection->window,
-                     selection->client_message_timestamp);
-  XFlush (xdisplay);
-}
-
-static void
-meta_x11_source_target (MetaWaylandDataSource *source,
-                        const gchar           *mime_type)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaWaylandDataSourceXWayland *source_xwayland =
-    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
-  MetaSelectionBridge *selection = source_xwayland->selection;
-  uint32_t action = 0;
-
-  if (selection->selection_atom == xdnd_atoms[ATOM_DND_SELECTION])
-    {
-      if (mime_type)
-        action = meta_wayland_data_source_get_current_action (source);
-
-      xdnd_send_status (compositor->xwayland_manager.selection_data,
-                        selection->owner, action);
-    }
-}
-
-static void
-meta_x11_source_cancel (MetaWaylandDataSource *source)
-{
-  MetaWaylandDataSourceXWayland *source_xwayland =
-    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
-  MetaSelectionBridge *selection = source_xwayland->selection;
-
-  x11_selection_data_send_finished (selection, FALSE);
-  g_clear_pointer (&selection->x11_selection,
-                   x11_selection_data_free);
-}
-
-static void
-meta_x11_source_action (MetaWaylandDataSource *source,
-                        uint32_t               action)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaWaylandDataSourceXWayland *source_xwayland =
-    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
-  MetaSelectionBridge *selection = source_xwayland->selection;
-
-  if (selection->selection_atom == xdnd_atoms[ATOM_DND_SELECTION])
-    {
-      if (!meta_wayland_data_source_has_target (source))
-        action = 0;
-
-      xdnd_send_status (compositor->xwayland_manager.selection_data,
-                        selection->owner, action);
-    }
-}
-
-static void
-meta_x11_source_drop_performed (MetaWaylandDataSource *source)
-{
-}
-
-static void
-meta_x11_source_drag_finished (MetaWaylandDataSource *source)
-{
-  MetaWaylandDataSourceXWayland *source_xwayland =
-    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
-  MetaSelectionBridge *selection = source_xwayland->selection;
-
-  if (selection->x11_selection)
-    x11_selection_data_send_finished (selection, TRUE);
-}
-
-static void
-meta_wayland_data_source_xwayland_init (MetaWaylandDataSourceXWayland *source_xwayland)
-{
-}
-
-static void
-meta_wayland_data_source_xwayland_class_init (MetaWaylandDataSourceXWaylandClass *klass)
-{
-  MetaWaylandDataSourceClass *data_source_class =
-    META_WAYLAND_DATA_SOURCE_CLASS (klass);
-
-  data_source_class->send = meta_x11_source_send;
-  data_source_class->target = meta_x11_source_target;
-  data_source_class->cancel = meta_x11_source_cancel;
-  data_source_class->action = meta_x11_source_action;
-  data_source_class->drop_performed = meta_x11_source_drop_performed;
-  data_source_class->drag_finished = meta_x11_source_drag_finished;
-}
-
-static MetaWaylandDataSource *
-meta_wayland_data_source_xwayland_new (MetaSelectionBridge *selection)
-{
-  MetaWaylandDataSourceXWayland *source_xwayland;
-
-  source_xwayland = g_object_new (META_TYPE_WAYLAND_DATA_SOURCE_XWAYLAND, NULL);
-  source_xwayland->selection = selection;
-
-  return META_WAYLAND_DATA_SOURCE (source_xwayland);
-}
-
-static void
-meta_x11_drag_dest_focus_in (MetaWaylandDataDevice *data_device,
-                             MetaWaylandSurface    *surface,
-                             MetaWaylandDataOffer  *offer)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-
-  compositor->xwayland_manager.selection_data->dnd.dnd_dest = surface->window->xwindow;
-  xdnd_send_enter (compositor->xwayland_manager.selection_data,
-                   compositor->xwayland_manager.selection_data->dnd.dnd_dest);
-}
-
-static void
-meta_x11_drag_dest_focus_out (MetaWaylandDataDevice *data_device,
-                              MetaWaylandSurface    *surface)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-
-  xdnd_send_leave (compositor->xwayland_manager.selection_data,
-                   compositor->xwayland_manager.selection_data->dnd.dnd_dest);
-  compositor->xwayland_manager.selection_data->dnd.dnd_dest = None;
-}
-
-static void
-meta_x11_drag_dest_motion (MetaWaylandDataDevice *data_device,
-                           MetaWaylandSurface    *surface,
-                           const ClutterEvent    *event)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  guint32 time;
-  gfloat x, y;
-
-  time = clutter_event_get_time (event);
-  clutter_event_get_coords (event, &x, &y);
-  xdnd_send_position (compositor->xwayland_manager.selection_data,
-                      compositor->xwayland_manager.selection_data->dnd.dnd_dest,
-                      time, x, y);
-}
-
-static void
-meta_x11_drag_dest_drop (MetaWaylandDataDevice *data_device,
-                         MetaWaylandSurface    *surface)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-
-  xdnd_send_drop (compositor->xwayland_manager.selection_data,
-                  compositor->xwayland_manager.selection_data->dnd.dnd_dest,
-                  meta_display_get_current_time_roundtrip (meta_get_display ()));
-}
-
-static void
-meta_x11_drag_dest_update (MetaWaylandDataDevice *data_device,
-                           MetaWaylandSurface    *surface)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaWaylandSeat *seat = compositor->seat;
-  ClutterPoint pos;
-
-  clutter_input_device_get_coords (seat->pointer->device, NULL, &pos);
-  xdnd_send_position (compositor->xwayland_manager.selection_data,
-                      compositor->xwayland_manager.selection_data->dnd.dnd_dest,
-                      clutter_get_current_event_time (),
-                      pos.x, pos.y);
-}
-
-static const MetaWaylandDragDestFuncs meta_x11_drag_dest_funcs = {
-  meta_x11_drag_dest_focus_in,
-  meta_x11_drag_dest_focus_out,
-  meta_x11_drag_dest_motion,
-  meta_x11_drag_dest_drop,
-  meta_x11_drag_dest_update
-};
-
-const MetaWaylandDragDestFuncs *
-meta_xwayland_selection_get_drag_dest_funcs (void)
-{
-  return &meta_x11_drag_dest_funcs;
-}
-
-static gboolean
-meta_xwayland_data_source_fetch_mimetype_list (MetaWaylandDataSource *source,
-                                               Window                 window,
-                                               Atom                   prop)
-{
-  MetaWaylandDataSourceXWayland *source_xwayland =
-    META_WAYLAND_DATA_SOURCE_XWAYLAND (source);
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  gulong nitems_ret, bytes_after_ret, i;
-  Atom *atoms, type_ret, utf8_string;
-  int format_ret;
-  struct wl_array *source_mime_types;
-
-  source_mime_types = meta_wayland_data_source_get_mime_types (source);
-  if (source_mime_types->size != 0)
-    return TRUE;
-
-  utf8_string = gdk_x11_get_xatom_by_name ("UTF8_STRING");
-  XGetWindowProperty (xdisplay, window, prop,
-                      0, /* offset */
-                      0x1fffffff, /* length */
-                      True, /* delete */
-                      AnyPropertyType,
-                      &type_ret,
-                      &format_ret,
-                      &nitems_ret,
-                      &bytes_after_ret,
-                      (guchar **) &atoms);
-
-  if (nitems_ret == 0 || type_ret != XA_ATOM)
-    {
-      XFree (atoms);
-      return FALSE;
-    }
-
-  for (i = 0; i < nitems_ret; i++)
-    {
-      const gchar *mime_type;
-
-      if (atoms[i] == utf8_string)
-        {
-          meta_wayland_data_source_add_mime_type (source,
-                                                  "text/plain;charset=utf-8");
-          source_xwayland->has_utf8_string_atom = TRUE;
-        }
-
-      mime_type = gdk_x11_get_xatom_name (atoms[i]);
-      meta_wayland_data_source_add_mime_type (source, mime_type);
-    }
-
-  XFree (atoms);
-
-  return TRUE;
-}
-
-static void
-meta_xwayland_selection_get_x11_targets (MetaWaylandCompositor *compositor,
-                                         MetaSelectionBridge   *selection)
-{
-  MetaWaylandDataSource *data_source;
-
-  data_source = meta_wayland_data_source_xwayland_new (selection);
-
-  if (meta_xwayland_data_source_fetch_mimetype_list (data_source,
-                                                     selection->window,
-                                                     gdk_x11_get_xatom_by_name ("_META_SELECTION")))
-    {
-      g_clear_object (&selection->source);
-      selection->source = data_source;
-
-      if (selection->selection_atom == gdk_x11_get_xatom_by_name ("CLIPBOARD"))
-        {
-          meta_wayland_data_device_set_selection (&compositor->seat->data_device, data_source,
-                                                  wl_display_next_serial (compositor->wayland_display));
-        }
-      else if (selection->selection_atom == gdk_x11_get_xatom_by_name ("PRIMARY"))
-        {
-          meta_wayland_data_device_set_primary (&compositor->seat->data_device, data_source,
-                                                wl_display_next_serial (compositor->wayland_display));
-        }
-    }
-  else
-    g_object_unref (data_source);
-}
-
-static void
-meta_xwayland_selection_get_x11_data (MetaWaylandCompositor *compositor,
-                                      MetaSelectionBridge   *selection)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  gulong nitems_ret, bytes_after_ret;
-  guchar *prop_ret;
-  int format_ret;
-  Atom type_ret;
-
-  if (!selection->x11_selection)
-    return;
-
-  XGetWindowProperty (xdisplay,
-                      selection->window,
-                      gdk_x11_get_xatom_by_name ("_META_SELECTION"),
-                      0, /* offset */
-                      0x1fffffff, /* length */
-                      True, /* delete */
-                      AnyPropertyType,
-                      &type_ret,
-                      &format_ret,
-                      &nitems_ret,
-                      &bytes_after_ret,
-                      &prop_ret);
-
-  selection->x11_selection->incr = (type_ret == gdk_x11_get_xatom_by_name ("INCR"));
-
-  if (selection->x11_selection->incr)
-    return;
-
-  if (type_ret == gdk_x11_get_xatom_by_name (selection->x11_selection->mime_type))
-    x11_selection_data_write (selection, prop_ret, nitems_ret);
-
-  XFree (prop_ret);
-}
-
-static gboolean
-meta_xwayland_selection_handle_selection_notify (MetaWaylandCompositor *compositor,
-                                                 XEvent                *xevent)
-{
-  XSelectionEvent *event = (XSelectionEvent *) xevent;
-  MetaSelectionBridge *selection;
-
-  selection = atom_to_selection_bridge (compositor, event->selection);
-
-  if (!selection)
-    return FALSE;
-
-  if (selection->window != event->requestor)
-    return FALSE;
-
-  /* convert selection failed */
-  if (event->property == None)
-    {
-      g_clear_pointer (&selection->x11_selection,
-                       x11_selection_data_free);
-      return FALSE;
-    }
-
-  if (event->target == gdk_x11_get_xatom_by_name ("TARGETS"))
-    meta_xwayland_selection_get_x11_targets (compositor, selection);
-  else
-    meta_xwayland_selection_get_x11_data (compositor, selection);
-
-  return TRUE;
-}
-
-static void
-meta_xwayland_selection_send_targets (MetaWaylandCompositor       *compositor,
-                                      const MetaWaylandDataSource *data_source,
-                                      Window                       requestor,
-                                      Atom                         property)
-{
-  Atom *targets;
-  gchar **p;
-  int i = 0;
-  struct wl_array *source_mime_types;
-
-  if (!data_source)
-    return;
-
-  source_mime_types = meta_wayland_data_source_get_mime_types (data_source);
-  if (source_mime_types->size == 0)
-    return;
-
-  /* Make extra room for TIMESTAMP/TARGETS */
-  targets = g_new (Atom, source_mime_types->size + 2);
-
-  wl_array_for_each (p, source_mime_types)
-    {
-      targets[i++] = gdk_x11_get_xatom_by_name (*p);
-    }
-
-  targets[i++] = gdk_x11_get_xatom_by_name ("TIMESTAMP");
-  targets[i++] = gdk_x11_get_xatom_by_name ("TARGETS");
-
-  XChangeProperty (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                   requestor, property,
-                   XA_ATOM, 32, PropModeReplace,
-                   (guchar *) targets, i);
-
-  g_free (targets);
-}
-
-static void
-meta_xwayland_selection_send_timestamp (MetaWaylandCompositor *compositor,
-                                        Window                 requestor,
-                                        Atom                   property,
-                                        Time                   timestamp)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-
-  XChangeProperty (xdisplay, requestor, property,
-                   XA_INTEGER, 32,
-                   PropModeReplace,
-                   (guchar *) &timestamp, 1);
-}
-
-static void
-meta_xwayland_selection_send_incr_chunk (MetaWaylandCompositor *compositor,
-                                         MetaSelectionBridge   *selection)
-{
-  if (!selection->wayland_selection)
-    return;
-
-  if (selection->wayland_selection->buffer_len > 0)
-    wayland_selection_update_x11_property (selection->wayland_selection);
-  else
-    wayland_selection_data_read (selection);
-}
-
-static gboolean
-handle_incr_chunk (MetaWaylandCompositor *compositor,
-                   MetaSelectionBridge   *selection,
-                   XPropertyEvent        *event)
-{
-  if (selection->x11_selection &&
-      selection->x11_selection->incr &&
-      event->window == selection->window &&
-      event->state == PropertyNewValue &&
-      event->atom == gdk_x11_get_xatom_by_name ("_META_SELECTION"))
-    {
-      /* X11 to Wayland */
-      meta_xwayland_selection_get_incr_chunk (compositor, selection);
-      return TRUE;
-    }
-  else if (selection->wayland_selection &&
-           selection->wayland_selection->incr &&
-           event->state == PropertyDelete &&
-           event->window == selection->wayland_selection->request_event.requestor &&
-           event->atom == selection->wayland_selection->request_event.property)
-    {
-      /* Wayland to X11 */
-      meta_xwayland_selection_send_incr_chunk (compositor, selection);
-      return TRUE;
-    }
-
-  return FALSE;
-}
-
-static gboolean
-meta_xwayland_selection_handle_property_notify (MetaWaylandCompositor *compositor,
-                                                XEvent                *xevent)
-{
-  MetaXWaylandSelection *selection_data = compositor->xwayland_manager.selection_data;
-  XPropertyEvent *event = (XPropertyEvent *) xevent;
-
-  return handle_incr_chunk (compositor, &selection_data->clipboard, event);
-}
-
-static gboolean
-meta_xwayland_selection_handle_selection_request (MetaWaylandCompositor *compositor,
-                                                  XEvent                *xevent)
-{
-  XSelectionRequestEvent *event = (XSelectionRequestEvent *) xevent;
-  MetaWaylandDataSource *data_source;
-  MetaSelectionBridge *selection;
-
-  selection = atom_to_selection_bridge (compositor, event->selection);
-
-  if (!selection)
-    return FALSE;
-
-  if (selection->window != event->owner)
-    return FALSE;
-
-  /* We must fetch from the currently active source, not the Xwayland one */
-  data_source = data_device_get_active_source_for_atom (&compositor->seat->data_device,
-                                                        selection->selection_atom);
-  if (!data_source)
-    return FALSE;
-
-  g_clear_pointer (&selection->wayland_selection,
-                   wayland_selection_data_free);
-
-  if (event->target == gdk_x11_get_xatom_by_name ("TARGETS"))
-    {
-      meta_xwayland_selection_send_targets (compositor,
-                                            data_source,
-                                            event->requestor,
-                                            event->property);
-      reply_selection_request (event, TRUE);
-    }
-  else if (event->target == gdk_x11_get_xatom_by_name ("TIMESTAMP"))
-    {
-      meta_xwayland_selection_send_timestamp (compositor,
-                                              event->requestor, event->property,
-                                              selection->timestamp);
-      reply_selection_request (event, TRUE);
-    }
-  else if (data_source && event->target == gdk_x11_get_xatom_by_name ("DELETE"))
-    {
-      reply_selection_request (event, TRUE);
-    }
-  else
-    {
-      if (data_source &&
-          meta_wayland_data_source_has_mime_type (data_source,
-                                                  gdk_x11_get_xatom_name (event->target)))
-        {
-          selection->wayland_selection = wayland_selection_data_new (event,
-                                                                     compositor);
-
-          if (selection->wayland_selection)
-            wayland_selection_data_read (selection);
-        }
-
-      if (!selection->wayland_selection)
-        reply_selection_request (event, FALSE);
-    }
-
-  return TRUE;
-}
-
-static MetaWaylandSurface *
-pick_drop_surface (MetaWaylandCompositor *compositor,
-                   const ClutterEvent    *event)
-{
-  MetaDisplay *display = meta_get_display ();
-  MetaWindow *focus_window = NULL;
-  ClutterPoint pos;
-
-  clutter_event_get_coords (event, &pos.x, &pos.y);
-  focus_window = meta_stack_get_default_focus_window_at_point (display->stack,
-                                                               NULL, NULL,
-                                                               pos.x, pos.y);
-  return focus_window ? focus_window->surface : NULL;
-}
-
-static void
-repick_drop_surface (MetaWaylandCompositor *compositor,
-                     MetaWaylandDragGrab   *drag_grab,
-                     const ClutterEvent    *event)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaDndBridge *dnd = &compositor->xwayland_manager.selection_data->dnd;
-  MetaWaylandSurface *focus = NULL;
-
-  focus = pick_drop_surface (compositor, event);
-  if (dnd->focus_surface == focus)
-    return;
-
-  dnd->focus_surface = focus;
-
-  if (focus &&
-      focus->window->client_type == META_WINDOW_CLIENT_TYPE_WAYLAND)
-    {
-      XMapRaised (xdisplay, dnd->dnd_window);
-      XMoveResizeWindow (xdisplay, dnd->dnd_window,
-                         focus->window->rect.x,
-                         focus->window->rect.y,
-                         focus->window->rect.width,
-                         focus->window->rect.height);
-    }
-  else
-    {
-      XMoveResizeWindow (xdisplay, dnd->dnd_window, -1, -1, 1, 1);
-      XUnmapWindow (xdisplay, dnd->dnd_window);
-    }
-}
-
-static void
-drag_xgrab_focus (MetaWaylandPointerGrab *grab,
-                  MetaWaylandSurface     *surface)
-{
-  /* Do not update the focus here. First, the surface may perfectly
-   * be the X11 source DnD icon window's, so we can only be fooled
-   * here. Second, delaying focus handling to XdndEnter/Leave
-   * makes us do the negotiation orderly on the X11 side.
-   */
-}
-
-static void
-drag_xgrab_motion (MetaWaylandPointerGrab *grab,
-                   const ClutterEvent     *event)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaDndBridge *dnd = &compositor->xwayland_manager.selection_data->dnd;
-  MetaWaylandSeat *seat = compositor->seat;
-
-  repick_drop_surface (compositor,
-                       (MetaWaylandDragGrab *) grab,
-                       event);
-
-  dnd->last_motion_time = clutter_event_get_time (event);
-  meta_wayland_pointer_send_motion (seat->pointer, event);
-}
-
-static void
-drag_xgrab_button (MetaWaylandPointerGrab *grab,
-                   const ClutterEvent     *event)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaWaylandSeat *seat = compositor->seat;
-  MetaWaylandDataSource *data_source;
-
-  meta_wayland_pointer_send_button (seat->pointer, event);
-  data_source = compositor->seat->data_device.dnd_data_source;
-
-  if (seat->pointer->button_count == 0 &&
-      (!meta_wayland_drag_grab_get_focus ((MetaWaylandDragGrab *) grab) ||
-       meta_wayland_data_source_get_current_action (data_source) ==
-       WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE))
-    meta_xwayland_end_dnd_grab (&seat->data_device);
-}
-
-static const MetaWaylandPointerGrabInterface drag_xgrab_interface = {
-  drag_xgrab_focus,
-  drag_xgrab_motion,
-  drag_xgrab_button,
-};
-
-static gboolean
-meta_xwayland_selection_handle_client_message (MetaWaylandCompositor *compositor,
-                                               XEvent                *xevent)
-{
-  XClientMessageEvent *event = (XClientMessageEvent *) xevent;
-  MetaDndBridge *dnd = &compositor->xwayland_manager.selection_data->dnd;
-  MetaWaylandSeat *seat = compositor->seat;
-
-  /* Source side messages */
-  if (event->window == dnd->selection.window)
-    {
-      MetaWaylandDataSource *data_source;
-      uint32_t action = 0;
-
-      data_source = compositor->seat->data_device.dnd_data_source;
-
-      if (!data_source)
-        return FALSE;
-
-      if (event->message_type == xdnd_atoms[ATOM_DND_STATUS])
-        {
-          /* The first bit in data.l[1] is set if the drag was accepted */
-          meta_wayland_data_source_set_has_target (data_source,
-                                                   (event->data.l[1] & 1) != 0);
-
-          /* data.l[4] contains the action atom */
-          if (event->data.l[4])
-            action = atom_to_action ((Atom) event->data.l[4]);
-
-          meta_wayland_data_source_set_current_action (data_source, action);
-          return TRUE;
-        }
-      else if (event->message_type == xdnd_atoms[ATOM_DND_FINISHED])
-        {
-          /* Reject messages mid-grab */
-          if (compositor->seat->data_device.current_grab)
-            return FALSE;
-
-          meta_wayland_data_source_notify_finish (data_source);
-          return TRUE;
-        }
-    }
-  /* Dest side messages */
-  else if (dnd->selection.source &&
-           compositor->seat->data_device.current_grab &&
-           (Window) event->data.l[0] == dnd->selection.owner)
-    {
-      MetaWaylandDragGrab *drag_grab = compositor->seat->data_device.current_grab;
-      MetaWaylandSurface *drag_focus = meta_wayland_drag_grab_get_focus (drag_grab);
-
-      if (!drag_focus &&
-          event->message_type != xdnd_atoms[ATOM_DND_ENTER])
-        return FALSE;
-
-      if (event->message_type == xdnd_atoms[ATOM_DND_ENTER])
-        {
-          /* Bit 1 in data.l[1] determines whether there's 3 or less mimetype
-           * atoms (and are thus contained in this same message), or whether
-           * there's more than 3 and we need to check the XdndTypeList property
-           * for the full list.
-           */
-          if (!(event->data.l[1] & 1))
-            {
-              /* Mimetypes are contained in this message */
-              const gchar *mimetype;
-              gint i;
-              struct wl_array *source_mime_types;
-
-              /* We only need to fetch once */
-              source_mime_types =
-                meta_wayland_data_source_get_mime_types (dnd->selection.source);
-              if (source_mime_types->size == 0)
-                {
-                  for (i = 2; i <= 4; i++)
-                    {
-                      if (event->data.l[i] == None)
-                        break;
-
-                      mimetype = gdk_x11_get_xatom_name (event->data.l[i]);
-                      meta_wayland_data_source_add_mime_type (dnd->selection.source,
-                                                              mimetype);
-                    }
-                }
-            }
-          else
-            {
-              /* Fetch mimetypes from type list */
-              meta_xwayland_data_source_fetch_mimetype_list (dnd->selection.source,
-                                                             event->data.l[0],
-                                                             xdnd_atoms[ATOM_DND_TYPE_LIST]);
-            }
-
-          meta_wayland_drag_grab_set_focus (drag_grab, dnd->focus_surface);
-          return TRUE;
-        }
-      else if (event->message_type == xdnd_atoms[ATOM_DND_POSITION])
-        {
-          ClutterEvent *motion;
-          ClutterPoint pos;
-          uint32_t action = 0;
-
-          dnd->selection.client_message_timestamp = event->data.l[3];
-
-          motion = clutter_event_new (CLUTTER_MOTION);
-          clutter_input_device_get_coords (seat->pointer->device, NULL, &pos);
-          clutter_event_set_coords (motion, pos.x, pos.y);
-          clutter_event_set_device (motion, seat->pointer->device);
-          clutter_event_set_source_device (motion, seat->pointer->device);
-          clutter_event_set_time (motion, dnd->last_motion_time);
-
-          action = atom_to_action ((Atom) event->data.l[4]);
-          meta_wayland_data_source_set_actions (dnd->selection.source, action);
-
-          meta_wayland_surface_drag_dest_motion (drag_focus, motion);
-          xdnd_send_status (compositor->xwayland_manager.selection_data,
-                            (Window) event->data.l[0],
-                            meta_wayland_data_source_get_current_action (dnd->selection.source));
-
-          clutter_event_free (motion);
-          return TRUE;
-        }
-      else if (event->message_type == xdnd_atoms[ATOM_DND_LEAVE])
-        {
-          meta_wayland_drag_grab_set_focus (drag_grab, NULL);
-          return TRUE;
-        }
-      else if (event->message_type == xdnd_atoms[ATOM_DND_DROP])
-        {
-          dnd->selection.client_message_timestamp = event->data.l[2];
-          meta_wayland_surface_drag_dest_drop (drag_focus);
-          meta_xwayland_end_dnd_grab (&seat->data_device);
-          return TRUE;
-        }
-    }
-
-  return FALSE;
-}
-
-static gboolean
-meta_xwayland_selection_handle_xfixes_selection_notify (MetaWaylandCompositor *compositor,
-                                                        XEvent                *xevent)
-{
-  XFixesSelectionNotifyEvent *event = (XFixesSelectionNotifyEvent *) xevent;
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaSelectionBridge *selection;
-
-  selection = atom_to_selection_bridge (compositor, event->selection);
-
-  if (!selection)
-    return FALSE;
-
-  if (selection->selection_atom == gdk_x11_get_xatom_by_name ("CLIPBOARD") ||
-      selection->selection_atom == gdk_x11_get_xatom_by_name ("PRIMARY"))
-    {
-      if (event->owner == None)
-        {
-          if (selection->source && selection->owner != selection->window)
-            {
-              /* An X client went away, clear the selection */
-              g_clear_object (&selection->source);
-            }
-
-          selection->owner = None;
-        }
-      else
-        {
-          selection->owner = event->owner;
-
-          if (selection->owner == selection->window)
-            {
-              /* This our own selection window */
-              selection->timestamp = event->timestamp;
-              return TRUE;
-            }
-
-          g_clear_pointer (&selection->x11_selection,
-                           x11_selection_data_free);
-
-          XConvertSelection (xdisplay,
-                             event->selection,
-                             gdk_x11_get_xatom_by_name ("TARGETS"),
-                             gdk_x11_get_xatom_by_name ("_META_SELECTION"),
-                             selection->window,
-                             META_CURRENT_TIME);
-          XFlush (xdisplay);
-        }
-    }
-  else if (selection->selection_atom == xdnd_atoms[ATOM_DND_SELECTION])
-    {
-      MetaWaylandDataDevice *data_device = &compositor->seat->data_device;
-      MetaWaylandSurface *focus;
-
-      selection->owner = event->owner;
-      focus = compositor->seat->pointer->focus_surface;
-
-      if (event->owner != None && event->owner != selection->window &&
-          focus && meta_xwayland_is_xwayland_surface (focus))
-        {
-          selection->client_message_timestamp = META_CURRENT_TIME;
-          selection->source = meta_wayland_data_source_xwayland_new (selection);
-          meta_wayland_data_device_set_dnd_source (&compositor->seat->data_device,
-                                                   selection->source);
-
-          meta_wayland_data_device_start_drag (data_device,
-                                               wl_resource_get_client (focus->resource),
-                                               &drag_xgrab_interface,
-                                               focus, selection->source,
-                                               NULL);
-        }
-      else if (event->owner == None)
-        {
-          meta_xwayland_end_dnd_grab (data_device);
-        }
-    }
-
-  return TRUE;
-}
-
-gboolean
-meta_xwayland_selection_handle_event (XEvent *xevent)
-{
-  MetaWaylandCompositor *compositor;
-
-  compositor = meta_wayland_compositor_get_default ();
-
-  if (!compositor->xwayland_manager.selection_data)
-    return FALSE;
-
-  switch (xevent->type)
-    {
-    case SelectionNotify:
-      return meta_xwayland_selection_handle_selection_notify (compositor, xevent);
-    case PropertyNotify:
-      return meta_xwayland_selection_handle_property_notify (compositor, xevent);
-    case SelectionRequest:
-      return meta_xwayland_selection_handle_selection_request (compositor, xevent);
-    case ClientMessage:
-      return meta_xwayland_selection_handle_client_message (compositor, xevent);
-    default:
-      {
-        MetaX11Display *x11_display = meta_get_display ()->x11_display;
-
-        if (xevent->type - x11_display->xfixes_event_base == XFixesSelectionNotify)
-          return meta_xwayland_selection_handle_xfixes_selection_notify (compositor, xevent);
-
-        return FALSE;
-      }
-    }
-}
-
-static void
-meta_selection_bridge_ownership_notify (struct wl_listener *listener,
-                                        void               *data)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaSelectionBridge *selection =
-    wl_container_of (listener, selection, ownership_listener);
-  MetaWaylandDataSource *owner = data;
-
-  if (!owner && selection->window == selection->owner)
-    {
-      XSetSelectionOwner (xdisplay, selection->selection_atom,
-                          None, selection->timestamp);
-    }
-  else if (owner && selection->source != owner)
-    {
-      XSetSelectionOwner (xdisplay,
-                          selection->selection_atom,
-                          selection->window,
-                          META_CURRENT_TIME);
-    }
-}
-
-static void
-init_selection_bridge (MetaSelectionBridge *selection,
-                       Atom                 selection_atom,
-                       struct wl_signal    *signal)
-{
-  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  XSetWindowAttributes attributes;
-  guint mask;
-
-  attributes.event_mask = PropertyChangeMask;
-
-  selection->ownership_listener.notify = meta_selection_bridge_ownership_notify;
-  wl_signal_add (signal, &selection->ownership_listener);
-
-  selection->selection_atom = selection_atom;
-  selection->window =
-    XCreateWindow (xdisplay,
-                   gdk_x11_window_get_xid (gdk_get_default_root_window ()),
-                   -1, -1, 1, 1, /* position */
-                   0, /* border width */
-                   0, /* depth */
-                   InputOnly, /* class */
-                   CopyFromParent, /* visual */
-                   CWEventMask,
-                   &attributes);
-
-  mask = XFixesSetSelectionOwnerNotifyMask |
-    XFixesSelectionWindowDestroyNotifyMask |
-    XFixesSelectionClientCloseNotifyMask;
-
-  XFixesSelectSelectionInput (xdisplay, selection->window,
-                              selection_atom, mask);
-}
-
-static void
-shutdown_selection_bridge (MetaSelectionBridge *selection)
-{
-  wl_list_remove (&selection->ownership_listener.link);
-
-  XDestroyWindow (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                  selection->window);
-  g_clear_pointer (&selection->wayland_selection,
-                   wayland_selection_data_free);
-  g_clear_pointer (&selection->x11_selection,
-                   x11_selection_data_free);
-}
-
-void
-meta_xwayland_init_selection (void)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaXWaylandManager *manager = &compositor->xwayland_manager;
-
-  g_assert (manager->selection_data == NULL);
-
-  manager->selection_data = g_slice_new0 (MetaXWaylandSelection);
-
-  meta_xwayland_init_dnd (manager);
-  init_selection_bridge (&manager->selection_data->clipboard,
-                         gdk_x11_get_xatom_by_name ("CLIPBOARD"),
-                         &compositor->seat->data_device.selection_ownership_signal);
-  init_selection_bridge (&manager->selection_data->primary,
-                         gdk_x11_get_xatom_by_name ("PRIMARY"),
-                         &compositor->seat->data_device.primary_ownership_signal);
-  init_selection_bridge (&manager->selection_data->dnd.selection,
-                         xdnd_atoms[ATOM_DND_SELECTION],
-                         &compositor->seat->data_device.dnd_ownership_signal);
-}
-
-void
-meta_xwayland_shutdown_selection (void)
-{
-  MetaWaylandCompositor *compositor = meta_wayland_compositor_get_default ();
-  MetaXWaylandManager *manager = &compositor->xwayland_manager;
-  MetaXWaylandSelection *selection = manager->selection_data;
-
-  g_assert (selection != NULL);
-
-  g_clear_object (&selection->clipboard.source);
-
-  meta_xwayland_shutdown_dnd (manager);
-  shutdown_selection_bridge (&selection->clipboard);
-  shutdown_selection_bridge (&selection->primary);
-  shutdown_selection_bridge (&selection->dnd.selection);
-
-  g_slice_free (MetaXWaylandSelection, selection);
-  manager->selection_data = NULL;
-}
diff --git a/src/wayland/meta-xwayland.c b/src/wayland/meta-xwayland.c
index 15c85df69760cd7668919f25f2ef4707ce992c88..90fdd222b133242c7566fc7dfa4ab9a20bc1020b 100644
--- a/src/wayland/meta-xwayland.c
+++ b/src/wayland/meta-xwayland.c
@@ -559,7 +559,7 @@ out:
 static void
 on_x11_display_closing (MetaDisplay *display)
 {
-  meta_xwayland_shutdown_selection ();
+  meta_xwayland_shutdown_dnd ();
 }
 
 /* To be called right after connecting */
@@ -575,7 +575,7 @@ meta_xwayland_complete_init (MetaDisplay *display)
 
   g_signal_connect (display, "x11-display-closing",
                     G_CALLBACK (on_x11_display_closing), NULL);
-  meta_xwayland_init_selection ();
+  meta_xwayland_init_dnd ();
 }
 
 void
diff --git a/src/x11/events.c b/src/x11/events.c
index e363fdbb6381365a8ec7fb2878096a7d94b9d070..92b5d70156bb723bb690a5df1f4fdc3b43a600ee 100644
--- a/src/x11/events.c
+++ b/src/x11/events.c
@@ -38,8 +38,11 @@
 #include "core/workspace-private.h"
 #include "meta/meta-backend.h"
 #include "meta/meta-x11-errors.h"
-#include "x11/meta-x11-display-private.h"
 #include "x11/meta-startup-notification-x11.h"
+#include "x11/meta-x11-display-private.h"
+#include "x11/meta-x11-selection-private.h"
+#include "x11/meta-x11-selection-input-stream-private.h"
+#include "x11/meta-x11-selection-output-stream-private.h"
 #include "x11/window-x11.h"
 #include "x11/xprops.h"
 
@@ -1717,6 +1720,24 @@ window_has_xwindow (MetaWindow *window,
   return FALSE;
 }
 
+static gboolean
+process_selection_event (MetaX11Display *x11_display,
+                         XEvent         *event)
+{
+  gboolean handled = FALSE;
+  GList *l;
+
+  handled |= meta_x11_selection_handle_event (x11_display, event);
+
+  for (l = x11_display->selection.input_streams; l && !handled; l = l->next)
+    handled |= meta_x11_selection_input_stream_xevent (l->data, event);
+
+  for (l = x11_display->selection.output_streams; l && !handled; l = l->next)
+    handled |= meta_x11_selection_output_stream_xevent (l->data, event);
+
+  return handled;
+}
+
 /**
  * meta_display_handle_xevent:
  * @display: The MetaDisplay that events are coming from
@@ -1753,13 +1774,19 @@ meta_x11_display_handle_xevent (MetaX11Display *x11_display,
 
 #ifdef HAVE_WAYLAND
   if (meta_is_wayland_compositor () &&
-      meta_xwayland_selection_handle_event (event))
+      meta_xwayland_dnd_handle_event (event))
     {
       bypass_gtk = bypass_compositor = TRUE;
       goto out;
     }
 #endif
 
+  if (process_selection_event (x11_display, event))
+    {
+      bypass_gtk = bypass_compositor = TRUE;
+      goto out;
+    }
+
   display->current_time = event_get_time (x11_display, event);
 
   if (META_IS_BACKEND_X11 (backend))
diff --git a/src/x11/meta-selection-source-x11-private.h b/src/x11/meta-selection-source-x11-private.h
new file mode 100644
index 0000000000000000000000000000000000000000..bcd21a356edfec099d66046e8b79225ea6898cc6
--- /dev/null
+++ b/src/x11/meta-selection-source-x11-private.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#ifndef META_SELECTION_SOURCE_X11_H
+#define META_SELECTION_SOURCE_X11_H
+
+#include "meta/meta-selection-source.h"
+#include "x11/meta-x11-display-private.h"
+
+#define META_TYPE_SELECTION_SOURCE_X11 (meta_selection_source_x11_get_type ())
+G_DECLARE_FINAL_TYPE (MetaSelectionSourceX11,
+                      meta_selection_source_x11,
+                      META, SELECTION_SOURCE_X11,
+                      MetaSelectionSource)
+
+void                  meta_selection_source_x11_new_async  (MetaX11Display      *display,
+                                                            Window               owner,
+                                                            uint32_t             timestamp,
+                                                            Atom                 xselection,
+                                                            GCancellable        *cancellable,
+                                                            GAsyncReadyCallback  callback,
+                                                            gpointer             user_data);
+MetaSelectionSource * meta_selection_source_x11_new_finish (GAsyncResult  *result,
+                                                            GError       **error);
+
+#endif /* META_SELECTION_SOURCE_X11_H */
diff --git a/src/x11/meta-selection-source-x11.c b/src/x11/meta-selection-source-x11.c
new file mode 100644
index 0000000000000000000000000000000000000000..15a763651cc5a0b325e2ed54a36ba91211818a15
--- /dev/null
+++ b/src/x11/meta-selection-source-x11.c
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#include "config.h"
+
+#include <gdk/gdkx.h>
+
+#include "x11/meta-x11-selection-input-stream-private.h"
+#include "x11/meta-selection-source-x11-private.h"
+
+#define MAX_MIMETYPE_SIZE 4096
+
+struct _MetaSelectionSourceX11
+{
+  MetaSelectionSource parent_instance;
+  MetaX11Display *x11_display;
+  GList *mimetypes;
+  Window owner;
+  Atom xselection;
+  uint32_t timestamp;
+};
+
+G_DEFINE_TYPE (MetaSelectionSourceX11, meta_selection_source_x11,
+               META_TYPE_SELECTION_SOURCE)
+
+static void
+stream_new_cb (GObject      *source,
+               GAsyncResult *res,
+               GTask        *task)
+{
+  GInputStream *stream;
+  GError *error = NULL;
+
+  stream = meta_x11_selection_input_stream_new_finish (res, NULL, NULL, &error);
+
+  if (stream)
+    g_task_return_pointer (task, stream, g_object_unref);
+  else
+    g_task_return_error (task, error);
+
+  g_object_unref (task);
+}
+
+static void
+meta_selection_source_x11_finalize (GObject *object)
+{
+  MetaSelectionSourceX11 *source_x11 = META_SELECTION_SOURCE_X11 (object);
+
+  g_list_free_full (source_x11->mimetypes, g_free);
+
+  G_OBJECT_CLASS (meta_selection_source_x11_parent_class)->finalize (object);
+}
+
+static void
+meta_selection_source_x11_read_async (MetaSelectionSource *source,
+                                      const gchar         *mimetype,
+                                      GCancellable        *cancellable,
+                                      GAsyncReadyCallback  callback,
+                                      gpointer             user_data)
+{
+  MetaSelectionSourceX11 *source_x11 = META_SELECTION_SOURCE_X11 (source);
+  GTask *task;
+
+  task = g_task_new (source, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_selection_source_x11_read_async);
+
+  meta_x11_selection_input_stream_new_async (source_x11->x11_display,
+                                             source_x11->x11_display->selection.xwindow,
+                                             gdk_x11_get_xatom_name (source_x11->xselection),
+                                             mimetype,
+                                             source_x11->timestamp,
+                                             G_PRIORITY_DEFAULT,
+                                             cancellable,
+                                             (GAsyncReadyCallback) stream_new_cb,
+                                             task);
+}
+
+static GInputStream *
+meta_selection_source_x11_read_finish (MetaSelectionSource  *source,
+                                       GAsyncResult         *result,
+                                       GError              **error)
+{
+  g_return_val_if_fail (g_task_is_valid (result, source), NULL);
+  g_return_val_if_fail (g_task_get_source_tag (G_TASK (result)) ==
+                        meta_selection_source_x11_read_async, NULL);
+
+  return g_task_propagate_pointer (G_TASK (result), error);
+}
+
+static GList *
+meta_selection_source_x11_get_mimetypes (MetaSelectionSource  *source)
+{
+  MetaSelectionSourceX11 *source_x11 = META_SELECTION_SOURCE_X11 (source);
+
+  return g_list_copy_deep (source_x11->mimetypes, (GCopyFunc) g_strdup, NULL);
+}
+
+static void
+meta_selection_source_x11_class_init (MetaSelectionSourceX11Class *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  MetaSelectionSourceClass *source_class = META_SELECTION_SOURCE_CLASS (klass);
+
+  object_class->finalize = meta_selection_source_x11_finalize;
+
+  source_class->read_async = meta_selection_source_x11_read_async;
+  source_class->read_finish = meta_selection_source_x11_read_finish;
+  source_class->get_mimetypes = meta_selection_source_x11_get_mimetypes;
+}
+
+static void
+meta_selection_source_x11_init (MetaSelectionSourceX11 *source)
+{
+}
+
+static GList *
+atoms_to_mimetypes (MetaX11Display *display,
+                    GBytes         *bytes)
+{
+  GList *mimetypes = NULL;
+  const Atom *atoms;
+  gsize size;
+  guint i, n_atoms;
+
+  atoms = g_bytes_get_data (bytes, &size);
+  n_atoms = size / sizeof (Atom);
+
+  for (i = 0; i < n_atoms; i++)
+    {
+      const gchar *mimetype;
+
+      mimetype = gdk_x11_get_xatom_name (atoms[i]);
+      mimetypes = g_list_prepend (mimetypes, g_strdup (mimetype));
+    }
+
+  return mimetypes;
+}
+
+static void
+read_mimetypes_cb (GInputStream *stream,
+                   GAsyncResult *res,
+                   GTask        *task)
+{
+  MetaSelectionSourceX11 *source_x11 = g_task_get_task_data (task);
+  GError *error = NULL;
+  GBytes *bytes;
+
+  bytes = g_input_stream_read_bytes_finish (stream, res, &error);
+  if (error)
+    {
+      g_task_return_error (task, error);
+      g_object_unref (task);
+      return;
+    }
+
+  source_x11->mimetypes = atoms_to_mimetypes (source_x11->x11_display, bytes);
+  g_bytes_unref (bytes);
+
+  g_task_return_pointer (task,
+                         g_object_ref (g_task_get_task_data (task)),
+                         g_object_unref);
+  g_object_unref (task);
+  g_object_unref (stream);
+}
+
+static void
+get_mimetypes_cb (GObject      *source,
+                  GAsyncResult *res,
+                  GTask        *task)
+{
+  GInputStream *stream;
+  GError *error = NULL;
+
+  stream = meta_x11_selection_input_stream_new_finish (res, NULL, NULL, &error);
+  if (error)
+    {
+      g_task_return_error (task, error);
+      g_object_unref (task);
+      return;
+    }
+
+  g_input_stream_read_bytes_async (stream,
+                                   MAX_MIMETYPE_SIZE,
+                                   G_PRIORITY_DEFAULT,
+                                   g_task_get_cancellable (task),
+                                   (GAsyncReadyCallback) read_mimetypes_cb,
+                                   task);
+}
+
+void
+meta_selection_source_x11_new_async (MetaX11Display      *x11_display,
+                                     Window               owner,
+                                     uint32_t             timestamp,
+                                     Atom                 xselection,
+                                     GCancellable        *cancellable,
+                                     GAsyncReadyCallback  callback,
+                                     gpointer             user_data)
+{
+  MetaSelectionSourceX11 *source;
+  GTask *task;
+
+  source = g_object_new (META_TYPE_SELECTION_SOURCE_X11, NULL);
+  source->x11_display = x11_display;
+  source->owner = owner;
+  source->timestamp = timestamp;
+  source->xselection = xselection;
+
+  task = g_task_new (NULL, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_selection_source_x11_new_async);
+  g_task_set_task_data (task, source, g_object_unref);
+
+  meta_x11_selection_input_stream_new_async (x11_display,
+                                             x11_display->selection.xwindow,
+                                             gdk_x11_get_xatom_name (xselection),
+                                             "TARGETS",
+                                             timestamp,
+                                             G_PRIORITY_DEFAULT,
+                                             cancellable,
+                                             (GAsyncReadyCallback) get_mimetypes_cb,
+                                             task);
+}
+
+MetaSelectionSource *
+meta_selection_source_x11_new_finish (GAsyncResult  *result,
+                                      GError       **error)
+{
+  GTask *task = G_TASK (result);
+
+  g_return_val_if_fail (g_task_is_valid (task, NULL), NULL);
+  g_return_val_if_fail (g_task_get_source_tag (task) ==
+                        meta_selection_source_x11_new_async, NULL);
+
+  return g_task_propagate_pointer (task, error);
+}
diff --git a/src/x11/meta-x11-display-private.h b/src/x11/meta-x11-display-private.h
index b104118887fcba33a0176cb919b45e717fbaab2d..9a8ab83b209cf773f4b3e711c13b7beb99c9f012 100644
--- a/src/x11/meta-x11-display-private.h
+++ b/src/x11/meta-x11-display-private.h
@@ -31,6 +31,7 @@
 #include "backends/meta-monitor-manager-private.h"
 #include "core/display-private.h"
 #include "meta/common.h"
+#include "meta/meta-selection-source.h"
 #include "meta/types.h"
 #include "meta/meta-x11-display.h"
 #include "meta-startup-notification-x11.h"
@@ -123,6 +124,15 @@ struct _MetaX11Display
 
   MetaUI *ui;
 
+  struct {
+    Window xwindow;
+    MetaSelectionSource *owners[META_N_SELECTION_TYPES];
+    GCancellable *cancellables[META_N_SELECTION_TYPES];
+
+    GList *input_streams;
+    GList *output_streams;
+  } selection;
+
   guint keys_grabbed : 1;
 
   int composite_event_base;
diff --git a/src/x11/meta-x11-display.c b/src/x11/meta-x11-display.c
index 8ce12b99405a306ad0166c7f3d33eef69fa83ccb..af8ae7a8d6d8a4e2a7fe635501bef91130d6d1c6 100644
--- a/src/x11/meta-x11-display.c
+++ b/src/x11/meta-x11-display.c
@@ -61,6 +61,7 @@
 
 #include "x11/events.h"
 #include "x11/group-props.h"
+#include "x11/meta-x11-selection-private.h"
 #include "x11/window-props.h"
 #include "x11/xprops.h"
 
@@ -105,6 +106,8 @@ meta_x11_display_dispose (GObject *object)
 
   meta_x11_display_ungrab_keys (x11_display);
 
+  meta_x11_selection_shutdown (x11_display);
+
   if (x11_display->ui)
     {
       meta_ui_free (x11_display->ui);
@@ -1327,6 +1330,7 @@ meta_x11_display_new (MetaDisplay *display, GError **error)
   set_x11_bell_is_audible (x11_display, meta_prefs_bell_is_audible ());
 
   meta_x11_startup_notification_init (x11_display);
+  meta_x11_selection_init (x11_display);
 
   return x11_display;
 }
diff --git a/src/x11/meta-x11-selection-input-stream-private.h b/src/x11/meta-x11-selection-input-stream-private.h
new file mode 100644
index 0000000000000000000000000000000000000000..3fcf9ffd16c7c15c48099da291a8fe734acf6610
--- /dev/null
+++ b/src/x11/meta-x11-selection-input-stream-private.h
@@ -0,0 +1,54 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2017 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Benjamin Otte <otte@gnome.org>
+ *         Christian Kellner <gicmo@gnome.org>
+ */
+
+#ifndef META_X11_SELECTION_INPUT_STREAM_H
+#define META_X11_SELECTION_INPUT_STREAM_H
+
+#include <gio/gio.h>
+
+#include "x11/meta-x11-display-private.h"
+
+#define META_TYPE_X11_SELECTION_INPUT_STREAM (meta_x11_selection_input_stream_get_type ())
+G_DECLARE_FINAL_TYPE (MetaX11SelectionInputStream,
+                      meta_x11_selection_input_stream,
+                      META, X11_SELECTION_INPUT_STREAM,
+                      GInputStream)
+
+void           meta_x11_selection_input_stream_new_async     (MetaX11Display             *x11_display,
+                                                              Window                      window,
+                                                              const char                 *selection,
+                                                              const char                 *target,
+                                                              guint32                     timestamp,
+                                                              int                         io_priority,
+                                                              GCancellable               *cancellable,
+                                                              GAsyncReadyCallback         callback,
+                                                              gpointer                    user_data);
+GInputStream * meta_x11_selection_input_stream_new_finish    (GAsyncResult               *result,
+                                                              const char                **type,
+                                                              int                        *format,
+                                                              GError                    **error);
+
+gboolean       meta_x11_selection_input_stream_xevent        (MetaX11SelectionInputStream *stream,
+                                                              const XEvent                *xevent);
+
+G_END_DECLS
+
+#endif /* META_X11_SELECTION_INPUT_STREAM_H */
diff --git a/src/x11/meta-x11-selection-input-stream.c b/src/x11/meta-x11-selection-input-stream.c
new file mode 100644
index 0000000000000000000000000000000000000000..44309ba98ef81e524f1c4e962deaa6a52d778641
--- /dev/null
+++ b/src/x11/meta-x11-selection-input-stream.c
@@ -0,0 +1,557 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/*
+ * Copyright (C) 2017 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Benjamin Otte <otte@gnome.org>
+ *         Christian Kellner <gicmo@gnome.org>
+ */
+
+#include "config.h"
+
+#include "meta-x11-selection-input-stream-private.h"
+
+#include <gdk/gdkx.h>
+
+#include "meta/meta-x11-errors.h"
+#include "x11/meta-x11-display-private.h"
+
+typedef struct MetaX11SelectionInputStreamPrivate MetaX11SelectionInputStreamPrivate;
+
+struct _MetaX11SelectionInputStream
+{
+  GInputStream parent_instance;
+};
+
+struct MetaX11SelectionInputStreamPrivate
+{
+  MetaX11Display *x11_display;
+  Window window;
+  GAsyncQueue *chunks;
+  char *selection;
+  Atom xselection;
+  char *target;
+  Atom xtarget;
+  char *property;
+  Atom xproperty;
+  const char *type;
+  Atom xtype;
+  int format;
+
+  GTask *pending_task;
+  uint8_t *pending_data;
+  size_t pending_size;
+
+  guint complete : 1;
+  guint incr : 1;
+};
+
+G_DEFINE_TYPE_WITH_PRIVATE (MetaX11SelectionInputStream,
+                            meta_x11_selection_input_stream,
+                            G_TYPE_INPUT_STREAM)
+
+static gboolean
+meta_x11_selection_input_stream_has_data (MetaX11SelectionInputStream *stream)
+{
+  MetaX11SelectionInputStreamPrivate *priv =
+    meta_x11_selection_input_stream_get_instance_private (stream);
+
+  return g_async_queue_length (priv->chunks) > 0 || priv->complete;
+}
+
+/* NB: blocks when no data is in buffer */
+static size_t
+meta_x11_selection_input_stream_fill_buffer (MetaX11SelectionInputStream *stream,
+                                             uint8_t                     *buffer,
+                                             size_t                       count)
+{
+  MetaX11SelectionInputStreamPrivate *priv =
+    meta_x11_selection_input_stream_get_instance_private (stream);
+  GBytes *bytes;
+  size_t result = 0;
+
+  g_async_queue_lock (priv->chunks);
+
+  for (bytes = g_async_queue_pop_unlocked (priv->chunks);
+       bytes != NULL && count > 0;
+       bytes = g_async_queue_try_pop_unlocked (priv->chunks))
+  {
+    size_t size = g_bytes_get_size (bytes);
+
+    if (size == 0)
+      {
+        /* EOF marker, put it back */
+        g_async_queue_push_front_unlocked (priv->chunks, bytes);
+        bytes = NULL;
+        break;
+      }
+    else if (size > count)
+      {
+        GBytes *subbytes;
+        if (buffer)
+          memcpy (buffer, g_bytes_get_data (bytes, NULL), count);
+        subbytes = g_bytes_new_from_bytes (bytes, count, size - count);
+        g_async_queue_push_front_unlocked (priv->chunks, subbytes);
+        size = count;
+      }
+    else
+      {
+        if (buffer)
+          memcpy (buffer, g_bytes_get_data (bytes, NULL), size);
+      }
+
+    g_bytes_unref (bytes);
+    result += size;
+    if (buffer)
+      buffer += size;
+    count -= size;
+  }
+
+  if (bytes)
+    g_async_queue_push_front_unlocked (priv->chunks, bytes);
+
+  g_async_queue_unlock (priv->chunks);
+
+  return result;
+}
+
+static void
+meta_x11_selection_input_stream_flush (MetaX11SelectionInputStream *stream)
+{
+  MetaX11SelectionInputStreamPrivate *priv =
+    meta_x11_selection_input_stream_get_instance_private (stream);
+  gssize written;
+
+  if (!meta_x11_selection_input_stream_has_data (stream))
+    return;
+
+  if (priv->pending_task == NULL)
+    return;
+
+  written = meta_x11_selection_input_stream_fill_buffer (stream,
+                                                         priv->pending_data,
+                                                         priv->pending_size);
+  g_task_return_int (priv->pending_task, written);
+
+  g_clear_object (&priv->pending_task);
+  priv->pending_data = NULL;
+  priv->pending_size = 0;
+}
+
+static void
+meta_x11_selection_input_stream_complete (MetaX11SelectionInputStream *stream)
+{
+  MetaX11SelectionInputStreamPrivate *priv =
+    meta_x11_selection_input_stream_get_instance_private (stream);
+
+  if (priv->complete)
+    return;
+
+  priv->complete = TRUE;
+
+  g_async_queue_push (priv->chunks, g_bytes_new (NULL, 0));
+  meta_x11_selection_input_stream_flush (stream);
+
+  priv->x11_display->selection.input_streams =
+    g_list_remove (priv->x11_display->selection.input_streams, stream);
+
+  g_object_unref (stream);
+}
+
+static gssize
+meta_x11_selection_input_stream_read (GInputStream  *input_stream,
+                                      void          *buffer,
+                                      size_t         count,
+                                      GCancellable  *cancellable,
+                                      GError       **error)
+{
+  MetaX11SelectionInputStream *stream =
+    META_X11_SELECTION_INPUT_STREAM (input_stream);
+
+  return meta_x11_selection_input_stream_fill_buffer (stream, buffer, count);
+}
+
+static gboolean
+meta_x11_selection_input_stream_close (GInputStream  *stream,
+                                       GCancellable  *cancellable,
+                                       GError       **error)
+{
+  return TRUE;
+}
+
+static void
+meta_x11_selection_input_stream_read_async (GInputStream        *input_stream,
+                                            void                *buffer,
+                                            size_t               count,
+                                            int                  io_priority,
+                                            GCancellable        *cancellable,
+                                            GAsyncReadyCallback  callback,
+                                            gpointer             user_data)
+{
+  MetaX11SelectionInputStream *stream =
+    META_X11_SELECTION_INPUT_STREAM (input_stream);
+  MetaX11SelectionInputStreamPrivate *priv =
+    meta_x11_selection_input_stream_get_instance_private (stream);
+  GTask *task;
+
+  task = g_task_new (stream, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_x11_selection_input_stream_read_async);
+  g_task_set_priority (task, io_priority);
+
+  if (meta_x11_selection_input_stream_has_data (stream))
+    {
+      gssize size;
+
+      size = meta_x11_selection_input_stream_fill_buffer (stream, buffer, count);
+      g_task_return_int (task, size);
+      g_object_unref (task);
+    }
+  else
+    {
+      priv->pending_data = buffer;
+      priv->pending_size = count;
+      priv->pending_task = task;
+    }
+}
+
+static gssize
+meta_x11_selection_input_stream_read_finish (GInputStream  *stream,
+                                             GAsyncResult  *result,
+                                             GError       **error)
+{
+  g_return_val_if_fail (g_task_is_valid (result, stream), -1);
+  g_return_val_if_fail (g_task_get_source_tag (G_TASK (result)) ==
+                        meta_x11_selection_input_stream_read_async, -1);
+
+  return g_task_propagate_int (G_TASK (result), error);
+}
+
+static void
+meta_x11_selection_input_stream_close_async (GInputStream        *stream,
+                                             int                  io_priority,
+                                             GCancellable        *cancellable,
+                                             GAsyncReadyCallback  callback,
+                                             gpointer             user_data)
+{
+  GTask *task;
+
+  task = g_task_new (stream, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_x11_selection_input_stream_close_async);
+  g_task_return_boolean (task, TRUE);
+  g_object_unref (task);
+}
+
+static gboolean
+meta_x11_selection_input_stream_close_finish (GInputStream  *stream,
+                                              GAsyncResult  *result,
+                                              GError       **error)
+{
+  return TRUE;
+}
+
+static void
+meta_x11_selection_input_stream_finalize (GObject *object)
+{
+  MetaX11SelectionInputStream *stream =
+    META_X11_SELECTION_INPUT_STREAM (object);
+  MetaX11SelectionInputStreamPrivate *priv =
+    meta_x11_selection_input_stream_get_instance_private (stream);
+
+  g_async_queue_unref (priv->chunks);
+
+  g_free (priv->selection);
+  g_free (priv->target);
+  g_free (priv->property);
+
+  G_OBJECT_CLASS (meta_x11_selection_input_stream_parent_class)->finalize (object);
+}
+
+static void
+meta_x11_selection_input_stream_class_init (MetaX11SelectionInputStreamClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GInputStreamClass *istream_class = G_INPUT_STREAM_CLASS (klass);
+
+  object_class->finalize = meta_x11_selection_input_stream_finalize;
+
+  istream_class->read_fn = meta_x11_selection_input_stream_read;
+  istream_class->close_fn = meta_x11_selection_input_stream_close;
+
+  istream_class->read_async = meta_x11_selection_input_stream_read_async;
+  istream_class->read_finish = meta_x11_selection_input_stream_read_finish;
+  istream_class->close_async = meta_x11_selection_input_stream_close_async;
+  istream_class->close_finish = meta_x11_selection_input_stream_close_finish;
+}
+
+static void
+meta_x11_selection_input_stream_init (MetaX11SelectionInputStream *stream)
+{
+  MetaX11SelectionInputStreamPrivate *priv =
+    meta_x11_selection_input_stream_get_instance_private (stream);
+
+  priv->chunks = g_async_queue_new_full ((GDestroyNotify) g_bytes_unref);
+}
+
+static void
+XFree_without_return_value (gpointer data)
+{
+  XFree (data);
+}
+
+static GBytes *
+get_selection_property (Display *xdisplay,
+                        Window   owner,
+                        Atom     property,
+                        Atom    *ret_type,
+                        gint    *ret_format)
+{
+  gulong nitems;
+  gulong nbytes;
+  Atom prop_type;
+  gint prop_format;
+  uint8_t *data = NULL;
+
+  if (XGetWindowProperty (xdisplay, owner, property,
+                          0, 0x1FFFFFFF, False,
+                          AnyPropertyType, &prop_type, &prop_format,
+                          &nitems, &nbytes, &data) != Success)
+    goto err;
+
+  if (prop_type != None)
+    {
+      size_t length;
+
+      switch (prop_format)
+        {
+        case 8:
+          length = nitems;
+          break;
+        case 16:
+          length = sizeof (short) * nitems;
+          break;
+        case 32:
+          length = sizeof (long) * nitems;
+          break;
+        default:
+          g_warning ("Unknown XGetWindowProperty() format %u", prop_format);
+          goto err;
+        }
+
+      *ret_type = prop_type;
+      *ret_format = prop_format;
+
+      return g_bytes_new_with_free_func (data,
+                                         length,
+                                         XFree_without_return_value,
+                                         data);
+    }
+
+err:
+  if (data)
+    XFree (data);
+
+  *ret_type = None;
+  *ret_format = 0;
+
+  return NULL;
+}
+
+gboolean
+meta_x11_selection_input_stream_xevent (MetaX11SelectionInputStream *stream,
+                                        const XEvent                *xevent)
+{
+  MetaX11SelectionInputStreamPrivate *priv =
+    meta_x11_selection_input_stream_get_instance_private (stream);
+  Display *xdisplay;
+  Window xwindow;
+  GBytes *bytes;
+  Atom type;
+  gint format;
+
+  xdisplay = priv->x11_display->xdisplay;
+  xwindow = priv->window;
+
+  if (xevent->xany.display != xdisplay ||
+      xevent->xany.window != xwindow)
+    return FALSE;
+
+  switch (xevent->type)
+    {
+    case PropertyNotify:
+      if (!priv->incr ||
+          xevent->xproperty.atom != priv->xproperty ||
+          xevent->xproperty.state != PropertyNewValue)
+        return FALSE;
+
+      bytes = get_selection_property (xdisplay, xwindow, xevent->xproperty.atom,
+                                      &type, &format);
+
+      if (bytes == NULL)
+        {
+          g_debug ("INCR request came out empty");
+          meta_x11_selection_input_stream_complete (stream);
+        }
+      else if (g_bytes_get_size (bytes) == 0 || type == None)
+        {
+          g_bytes_unref (bytes);
+          meta_x11_selection_input_stream_complete (stream);
+        }
+      else
+        {
+          g_async_queue_push (priv->chunks, bytes);
+          meta_x11_selection_input_stream_flush (stream);
+        }
+
+      XDeleteProperty (xdisplay, xwindow, xevent->xproperty.atom);
+
+      return FALSE;
+
+    case SelectionNotify:
+      {
+        GTask *task;
+
+        /* selection is not for us */
+        if (priv->xselection != xevent->xselection.selection ||
+            priv->xtarget != xevent->xselection.target)
+          return FALSE;
+
+        /* We already received a selectionNotify before */
+        if (priv->pending_task == NULL ||
+            g_task_get_source_tag (priv->pending_task) != meta_x11_selection_input_stream_new_async)
+          {
+            g_debug ("Misbehaving client sent a reentrant SelectionNotify");
+            return FALSE;
+          }
+
+        task = g_steal_pointer (&priv->pending_task);
+
+        if (xevent->xselection.property == None)
+          {
+            g_task_return_new_error (task,
+                                     G_IO_ERROR,
+                                     G_IO_ERROR_NOT_FOUND,
+                                     _("Format %s not supported"), priv->target);
+            meta_x11_selection_input_stream_complete (stream);
+          }
+        else
+          {
+            bytes = get_selection_property (xdisplay, xwindow,
+                                            xevent->xselection.property,
+                                            &priv->xtype, &priv->format);
+            priv->type = gdk_x11_get_xatom_name (priv->xtype);
+
+            g_task_return_pointer (task, g_object_ref (stream), g_object_unref);
+
+            if (bytes == NULL)
+              {
+                meta_x11_selection_input_stream_complete (stream);
+              }
+            else
+              {
+                if (priv->xtype == XInternAtom (priv->x11_display->xdisplay, "INCR", False))
+                  {
+                    /* The remainder of the selection will come through PropertyNotify
+                       events on xwindow */
+                    priv->incr = TRUE;
+                    meta_x11_selection_input_stream_flush (stream);
+                  }
+                else
+                  {
+                    g_async_queue_push (priv->chunks, bytes);
+
+                    meta_x11_selection_input_stream_complete (stream);
+                  }
+              }
+
+            XDeleteProperty (xdisplay, xwindow, xevent->xselection.property);
+          }
+
+        g_object_unref (task);
+      }
+      return TRUE;
+
+    default:
+      return FALSE;
+    }
+}
+
+void
+meta_x11_selection_input_stream_new_async (MetaX11Display      *x11_display,
+                                           Window               window,
+                                           const char          *selection,
+                                           const char          *target,
+                                           guint32              timestamp,
+                                           int                  io_priority,
+                                           GCancellable        *cancellable,
+                                           GAsyncReadyCallback  callback,
+                                           gpointer             user_data)
+{
+  MetaX11SelectionInputStream *stream;
+  MetaX11SelectionInputStreamPrivate *priv;
+
+  stream = g_object_new (META_TYPE_X11_SELECTION_INPUT_STREAM, NULL);
+  priv = meta_x11_selection_input_stream_get_instance_private (stream);
+
+  priv->x11_display = x11_display;
+  x11_display->selection.input_streams =
+    g_list_prepend (x11_display->selection.input_streams, stream);
+  priv->selection = g_strdup (selection);
+  priv->xselection = XInternAtom (x11_display->xdisplay, priv->selection, False);
+  priv->target = g_strdup (target);
+  priv->xtarget = XInternAtom (x11_display->xdisplay, priv->target, False);
+  priv->property = g_strdup_printf ("META_SELECTION_%p", stream);
+  priv->xproperty = XInternAtom (x11_display->xdisplay, priv->property, False);
+  priv->window = window;
+
+  XConvertSelection (x11_display->xdisplay,
+                     priv->xselection,
+                     priv->xtarget,
+                     priv->xproperty,
+                     window,
+                     timestamp);
+
+  priv->pending_task = g_task_new (NULL, cancellable, callback, user_data);
+  g_task_set_source_tag (priv->pending_task, meta_x11_selection_input_stream_new_async);
+  g_task_set_priority (priv->pending_task, io_priority);
+}
+
+GInputStream *
+meta_x11_selection_input_stream_new_finish (GAsyncResult  *result,
+                                            const char   **type,
+                                            int           *format,
+                                            GError       **error)
+{
+  MetaX11SelectionInputStream *stream;
+  MetaX11SelectionInputStreamPrivate *priv;
+  GTask *task;
+
+  g_return_val_if_fail (g_task_is_valid (result, NULL), NULL);
+  task = G_TASK (result);
+  g_return_val_if_fail (g_task_get_source_tag (task) ==
+                        meta_x11_selection_input_stream_new_async, NULL);
+
+  stream = g_task_propagate_pointer (task, error);
+  if (!stream)
+    return NULL;
+
+  priv = meta_x11_selection_input_stream_get_instance_private (stream);
+
+  if (type)
+    *type = priv->type;
+  if (format)
+    *format = priv->format;
+
+  return G_INPUT_STREAM (stream);
+}
diff --git a/src/x11/meta-x11-selection-output-stream-private.h b/src/x11/meta-x11-selection-output-stream-private.h
new file mode 100644
index 0000000000000000000000000000000000000000..83390da485302ee03e1c87211f01220fde0b6cb6
--- /dev/null
+++ b/src/x11/meta-x11-selection-output-stream-private.h
@@ -0,0 +1,47 @@
+/* GIO - GLib Output, Output and Streaming Library
+ *
+ * Copyright (C) 2017 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Benjamin Otte <otte@gnome.org>
+ *         Christian Kellner <gicmo@gnome.org>
+ */
+
+#ifndef META_X11_SELECTION_OUTPUT_STREAM_H
+#define META_X11_SELECTION_OUTPUT_STREAM_H
+
+#include <gio/gio.h>
+
+#include "x11/meta-x11-display-private.h"
+
+#define META_TYPE_X11_SELECTION_OUTPUT_STREAM (meta_x11_selection_output_stream_get_type ())
+G_DECLARE_FINAL_TYPE (MetaX11SelectionOutputStream,
+                      meta_x11_selection_output_stream,
+                      META, X11_SELECTION_OUTPUT_STREAM,
+                      GOutputStream)
+
+GOutputStream * meta_x11_selection_output_stream_new         (MetaX11Display                *x11_display,
+                                                              Window                         window,
+                                                              const char                    *selection,
+                                                              const char                    *target,
+                                                              const char                    *property,
+                                                              const char                    *type,
+                                                              int                            format,
+                                                              gulong                         timestamp);
+
+gboolean        meta_x11_selection_output_stream_xevent        (MetaX11SelectionOutputStream *stream,
+                                                                const XEvent                 *xevent);
+
+#endif /* META_X11_SELECTION_OUTPUT_STREAM_H */
diff --git a/src/x11/meta-x11-selection-output-stream.c b/src/x11/meta-x11-selection-output-stream.c
new file mode 100644
index 0000000000000000000000000000000000000000..723903835edfc92649c3d4a30f4e9ac6e3e3d426
--- /dev/null
+++ b/src/x11/meta-x11-selection-output-stream.c
@@ -0,0 +1,606 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/*
+ * Copyright (C) 2017 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Benjamin Otte <otte@gnome.org>
+ *         Christian Kellner <gicmo@gnome.org>
+ */
+
+#include "config.h"
+
+#include "meta-x11-selection-output-stream-private.h"
+
+#include "meta/meta-x11-errors.h"
+#include "x11/meta-x11-display-private.h"
+
+typedef struct _MetaX11SelectionOutputStreamPrivate MetaX11SelectionOutputStreamPrivate;
+
+struct _MetaX11SelectionOutputStream
+{
+  GOutputStream parent_instance;
+};
+
+struct _MetaX11SelectionOutputStreamPrivate
+{
+  MetaX11Display *x11_display;
+  Window xwindow;
+  char *selection;
+  Atom xselection;
+  char *target;
+  Atom xtarget;
+  char *property;
+  Atom xproperty;
+  const char *type;
+  Atom xtype;
+  int format;
+  gulong timestamp;
+
+  GMutex mutex;
+  GCond cond;
+  GByteArray *data;
+  guint flush_requested : 1;
+
+  GTask *pending_task;
+
+  guint incr : 1;
+  guint delete_pending : 1;
+};
+
+G_DEFINE_TYPE_WITH_PRIVATE (MetaX11SelectionOutputStream,
+                            meta_x11_selection_output_stream,
+                            G_TYPE_OUTPUT_STREAM);
+
+static void
+meta_x11_selection_output_stream_notify_selection (MetaX11SelectionOutputStream *stream)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+  XSelectionEvent event;
+  Display *xdisplay;
+
+  event = (XSelectionEvent) {
+    .type = SelectionNotify,
+    .time = priv->timestamp,
+    .requestor = priv->xwindow,
+    .selection = priv->xselection,
+    .target = priv->xtarget,
+    .property = priv->xproperty,
+  };
+
+  meta_x11_error_trap_push (priv->x11_display);
+
+  xdisplay = priv->x11_display->xdisplay;
+
+  XSendEvent (xdisplay,
+              priv->xwindow, False, NoEventMask,
+              (XEvent *) &event);
+  XSync (xdisplay, False);
+
+  meta_x11_error_trap_pop (priv->x11_display);
+}
+
+static gboolean
+meta_x11_selection_output_stream_can_flush (MetaX11SelectionOutputStream *stream)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+
+  if (priv->delete_pending)
+    return FALSE;
+
+  return TRUE;
+}
+
+static size_t
+get_max_request_size (MetaX11Display *display)
+{
+  size_t size;
+
+  size = XExtendedMaxRequestSize (display->xdisplay);
+  if (size <= 0)
+    size = XMaxRequestSize (display->xdisplay);
+
+  return size - 100;
+}
+
+static gboolean
+meta_x11_selection_output_stream_needs_flush_unlocked (MetaX11SelectionOutputStream *stream)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+
+  if (priv->data->len == 0)
+    return FALSE;
+
+  if (g_output_stream_is_closing (G_OUTPUT_STREAM (stream)))
+    return TRUE;
+
+  if (priv->flush_requested)
+    return TRUE;
+
+  return priv->data->len >= get_max_request_size (priv->x11_display);
+}
+
+static gboolean
+meta_x11_selection_output_stream_needs_flush (MetaX11SelectionOutputStream *stream)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+
+  gboolean result;
+
+  g_mutex_lock (&priv->mutex);
+
+  result = meta_x11_selection_output_stream_needs_flush_unlocked (stream);
+
+  g_mutex_unlock (&priv->mutex);
+
+  return result;
+}
+
+static size_t
+get_element_size (int format)
+{
+  switch (format)
+    {
+    case 8:
+      return 1;
+
+    case 16:
+      return sizeof (short);
+
+    case 32:
+      return sizeof (long);
+
+    default:
+      g_warning ("Unknown format %u", format);
+      return 1;
+    }
+}
+
+static void
+meta_x11_selection_output_stream_perform_flush (MetaX11SelectionOutputStream *stream)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+  Display *xdisplay;
+  size_t element_size, n_elements;
+
+  g_assert (!priv->delete_pending);
+
+  xdisplay = priv->x11_display->xdisplay;
+
+  /* We operate on a foreign window, better guard against catastrophe */
+  meta_x11_error_trap_push (priv->x11_display);
+
+  g_mutex_lock (&priv->mutex);
+
+  element_size = get_element_size (priv->format);
+  n_elements = priv->data->len / element_size;
+
+  if (!g_output_stream_is_closing (G_OUTPUT_STREAM (stream)))
+    {
+      XWindowAttributes attrs;
+
+      priv->incr = TRUE;
+      XGetWindowAttributes (xdisplay,
+			    priv->xwindow,
+			    &attrs);
+      if (!(attrs.your_event_mask & PropertyChangeMask))
+        {
+          XSelectInput (xdisplay, priv->xwindow, attrs.your_event_mask | PropertyChangeMask);
+        }
+
+      XChangeProperty (xdisplay,
+                       priv->xwindow,
+                       priv->xproperty,
+                       XInternAtom (priv->x11_display->xdisplay, "INCR", True),
+                       32,
+                       PropModeReplace,
+                       (guchar *) &(long) { n_elements },
+                       1);
+    }
+  else
+    {
+      XChangeProperty (xdisplay,
+                       priv->xwindow,
+                       priv->xproperty,
+                       priv->xtype,
+                       priv->format,
+                       PropModeReplace,
+                       priv->data->data,
+                       n_elements);
+      g_byte_array_remove_range (priv->data, 0, n_elements * element_size);
+      if (priv->data->len < element_size)
+        priv->flush_requested = FALSE;
+    }
+
+  meta_x11_selection_output_stream_notify_selection (stream);
+
+  priv->delete_pending = TRUE;
+  g_cond_broadcast (&priv->cond);
+  g_mutex_unlock (&priv->mutex);
+
+  /* XXX: handle failure here and report EPIPE for future operations on the stream? */
+  if (meta_x11_error_trap_pop_with_return (priv->x11_display))
+    g_warning ("Failed to flush selection output stream");
+
+  if (priv->pending_task)
+    {
+      size_t result;
+
+      result = GPOINTER_TO_SIZE (g_task_get_task_data (priv->pending_task));
+      g_task_return_int (priv->pending_task, result);
+      g_object_unref (priv->pending_task);
+      priv->pending_task = NULL;
+    }
+}
+
+static gboolean
+meta_x11_selection_output_stream_invoke_flush (gpointer data)
+{
+  MetaX11SelectionOutputStream *stream =
+    META_X11_SELECTION_OUTPUT_STREAM (data);
+
+  if (meta_x11_selection_output_stream_needs_flush (stream) &&
+      meta_x11_selection_output_stream_can_flush (stream))
+    meta_x11_selection_output_stream_perform_flush (stream);
+
+  return G_SOURCE_REMOVE;
+}
+
+static gssize
+meta_x11_selection_output_stream_write (GOutputStream  *output_stream,
+                                        const void     *buffer,
+                                        size_t          count,
+                                        GCancellable   *cancellable,
+                                        GError        **error)
+{
+  MetaX11SelectionOutputStream *stream =
+    META_X11_SELECTION_OUTPUT_STREAM (output_stream);
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+
+  g_mutex_lock (&priv->mutex);
+  g_byte_array_append (priv->data, buffer, count);
+  g_mutex_unlock (&priv->mutex);
+
+  g_main_context_invoke (NULL, meta_x11_selection_output_stream_invoke_flush, stream);
+
+  g_mutex_lock (&priv->mutex);
+  if (meta_x11_selection_output_stream_needs_flush_unlocked (stream))
+    g_cond_wait (&priv->cond, &priv->mutex);
+  g_mutex_unlock (&priv->mutex);
+
+  return count;
+}
+
+static void
+meta_x11_selection_output_stream_write_async (GOutputStream       *output_stream,
+                                              const void          *buffer,
+                                              size_t               count,
+                                              int                  io_priority,
+                                              GCancellable        *cancellable,
+                                              GAsyncReadyCallback  callback,
+                                              gpointer             user_data)
+{
+  MetaX11SelectionOutputStream *stream =
+    META_X11_SELECTION_OUTPUT_STREAM (output_stream);
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+  GTask *task;
+
+  task = g_task_new (stream, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_x11_selection_output_stream_write_async);
+  g_task_set_priority (task, io_priority);
+
+  g_mutex_lock (&priv->mutex);
+  g_byte_array_append (priv->data, buffer, count);
+  g_mutex_unlock (&priv->mutex);
+
+  if (!meta_x11_selection_output_stream_needs_flush (stream))
+    {
+      g_task_return_int (task, count);
+      g_object_unref (task);
+      return;
+    }
+  else if (!meta_x11_selection_output_stream_can_flush (stream))
+    {
+      g_assert (priv->pending_task == NULL);
+      priv->pending_task = task;
+      g_task_set_task_data (task, GSIZE_TO_POINTER (count), NULL);
+      return;
+    }
+  else
+    {
+      meta_x11_selection_output_stream_perform_flush (stream);
+      g_task_return_int (task, count);
+      g_object_unref (task);
+      return;
+    }
+}
+
+static gssize
+meta_x11_selection_output_stream_write_finish (GOutputStream  *stream,
+                                               GAsyncResult   *result,
+                                               GError        **error)
+{
+  g_return_val_if_fail (g_task_is_valid (result, stream), -1);
+  g_return_val_if_fail (g_task_get_source_tag (G_TASK (result)) ==
+                        meta_x11_selection_output_stream_write_async, -1);
+
+  return g_task_propagate_int (G_TASK (result), error);
+}
+
+static gboolean
+meta_x11_selection_output_request_flush (MetaX11SelectionOutputStream *stream)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+  gboolean needs_flush;
+
+  g_mutex_lock (&priv->mutex);
+
+  if (priv->data->len >= get_element_size (priv->format))
+    priv->flush_requested = TRUE;
+
+  needs_flush = meta_x11_selection_output_stream_needs_flush_unlocked (stream);
+  g_mutex_unlock (&priv->mutex);
+
+  return needs_flush;
+}
+
+static gboolean
+meta_x11_selection_output_stream_flush (GOutputStream  *output_stream,
+                                        GCancellable   *cancellable,
+                                        GError        **error)
+{
+  MetaX11SelectionOutputStream *stream =
+    META_X11_SELECTION_OUTPUT_STREAM (output_stream);
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+
+  if (!meta_x11_selection_output_request_flush (stream))
+    return TRUE;
+
+  g_main_context_invoke (NULL, meta_x11_selection_output_stream_invoke_flush,
+                         stream);
+
+  g_mutex_lock (&priv->mutex);
+  if (meta_x11_selection_output_stream_needs_flush_unlocked (stream))
+    g_cond_wait (&priv->cond, &priv->mutex);
+  g_mutex_unlock (&priv->mutex);
+
+  return TRUE;
+}
+
+static void
+meta_x11_selection_output_stream_flush_async (GOutputStream       *output_stream,
+                                              int                  io_priority,
+                                              GCancellable        *cancellable,
+                                              GAsyncReadyCallback  callback,
+                                              gpointer             user_data)
+{
+  MetaX11SelectionOutputStream *stream =
+    META_X11_SELECTION_OUTPUT_STREAM (output_stream);
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+  GTask *task;
+
+  task = g_task_new (stream, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_x11_selection_output_stream_flush_async);
+  g_task_set_priority (task, io_priority);
+
+  if (!meta_x11_selection_output_stream_can_flush (stream))
+    {
+      if (meta_x11_selection_output_request_flush (stream))
+        {
+          g_assert (priv->pending_task == NULL);
+          priv->pending_task = task;
+          return;
+        }
+      else
+        {
+          g_task_return_boolean (task, TRUE);
+          g_object_unref (task);
+          return;
+        }
+    }
+
+  meta_x11_selection_output_stream_perform_flush (stream);
+  g_task_return_boolean (task, TRUE);
+  g_object_unref (task);
+  return;
+}
+
+static gboolean
+meta_x11_selection_output_stream_flush_finish (GOutputStream  *stream,
+                                               GAsyncResult   *result,
+                                               GError        **error)
+{
+  g_return_val_if_fail (g_task_is_valid (result, stream), FALSE);
+  g_return_val_if_fail (g_async_result_is_tagged (result, meta_x11_selection_output_stream_flush_async), FALSE);
+
+  return g_task_propagate_boolean (G_TASK (result), error);
+}
+
+static gboolean
+meta_x11_selection_output_stream_invoke_close (gpointer stream)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+
+  priv->x11_display->selection.output_streams =
+    g_list_remove (priv->x11_display->selection.output_streams, stream);
+
+  return G_SOURCE_REMOVE;
+}
+
+static gboolean
+meta_x11_selection_output_stream_close (GOutputStream  *stream,
+                                        GCancellable   *cancellable,
+                                        GError        **error)
+{
+  g_main_context_invoke (NULL, meta_x11_selection_output_stream_invoke_close, stream);
+
+  return TRUE;
+}
+
+static void
+meta_x11_selection_output_stream_close_async (GOutputStream       *stream,
+                                              int                  io_priority,
+                                              GCancellable        *cancellable,
+                                              GAsyncReadyCallback  callback,
+                                              gpointer             user_data)
+{
+  GTask *task;
+
+  task = g_task_new (stream, cancellable, callback, user_data);
+  g_task_set_source_tag (task, meta_x11_selection_output_stream_close_async);
+  g_task_set_priority (task, io_priority);
+
+  meta_x11_selection_output_stream_invoke_close (stream);
+  g_task_return_boolean (task, TRUE);
+
+  g_object_unref (task);
+}
+
+static gboolean
+meta_x11_selection_output_stream_close_finish (GOutputStream  *stream,
+                                               GAsyncResult   *result,
+                                               GError        **error)
+{
+  g_return_val_if_fail (g_task_is_valid (result, stream), FALSE);
+  g_return_val_if_fail (g_async_result_is_tagged (result, meta_x11_selection_output_stream_close_async), FALSE);
+
+  return g_task_propagate_boolean (G_TASK (result), error);
+}
+
+static void
+meta_x11_selection_output_stream_finalize (GObject *object)
+{
+  MetaX11SelectionOutputStream *stream =
+    META_X11_SELECTION_OUTPUT_STREAM (object);
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+
+  g_byte_array_unref (priv->data);
+  g_cond_clear (&priv->cond);
+  g_mutex_clear (&priv->mutex);
+
+  g_free (priv->selection);
+  g_free (priv->target);
+  g_free (priv->property);
+
+  G_OBJECT_CLASS (meta_x11_selection_output_stream_parent_class)->finalize (object);
+}
+
+static void
+meta_x11_selection_output_stream_class_init (MetaX11SelectionOutputStreamClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GOutputStreamClass *output_stream_class = G_OUTPUT_STREAM_CLASS (klass);
+
+  object_class->finalize = meta_x11_selection_output_stream_finalize;
+
+  output_stream_class->write_fn = meta_x11_selection_output_stream_write;
+  output_stream_class->flush = meta_x11_selection_output_stream_flush;
+  output_stream_class->close_fn = meta_x11_selection_output_stream_close;
+
+  output_stream_class->write_async = meta_x11_selection_output_stream_write_async;
+  output_stream_class->write_finish = meta_x11_selection_output_stream_write_finish;
+  output_stream_class->flush_async = meta_x11_selection_output_stream_flush_async;
+  output_stream_class->flush_finish = meta_x11_selection_output_stream_flush_finish;
+  output_stream_class->close_async = meta_x11_selection_output_stream_close_async;
+  output_stream_class->close_finish = meta_x11_selection_output_stream_close_finish;
+}
+
+static void
+meta_x11_selection_output_stream_init (MetaX11SelectionOutputStream *stream)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+
+  g_mutex_init (&priv->mutex);
+  g_cond_init (&priv->cond);
+  priv->data = g_byte_array_new ();
+}
+
+gboolean
+meta_x11_selection_output_stream_xevent (MetaX11SelectionOutputStream *stream,
+                                         const XEvent                 *xevent)
+{
+  MetaX11SelectionOutputStreamPrivate *priv =
+    meta_x11_selection_output_stream_get_instance_private (stream);
+  Display *xdisplay = priv->x11_display->xdisplay;
+
+  if (xevent->xany.display != xdisplay ||
+      xevent->xany.window != priv->xwindow)
+    return FALSE;
+
+  switch (xevent->type)
+    {
+    case PropertyNotify:
+      if (!priv->incr ||
+          xevent->xproperty.atom != priv->xproperty ||
+          xevent->xproperty.state != PropertyDelete)
+        return FALSE;
+
+      priv->delete_pending = FALSE;
+      if (meta_x11_selection_output_stream_needs_flush (stream) &&
+          meta_x11_selection_output_stream_can_flush (stream))
+        meta_x11_selection_output_stream_perform_flush (stream);
+      return FALSE;
+
+    default:
+      return FALSE;
+    }
+}
+
+GOutputStream *
+meta_x11_selection_output_stream_new (MetaX11Display *x11_display,
+                                      Window          requestor,
+                                      const char     *selection,
+                                      const char     *target,
+                                      const char     *property,
+                                      const char     *type,
+                                      int             format,
+                                      gulong          timestamp)
+{
+  MetaX11SelectionOutputStream *stream;
+  MetaX11SelectionOutputStreamPrivate *priv;
+
+  stream = g_object_new (META_TYPE_X11_SELECTION_OUTPUT_STREAM, NULL);
+  priv = meta_x11_selection_output_stream_get_instance_private (stream);
+
+  x11_display->selection.output_streams =
+    g_list_prepend (x11_display->selection.output_streams, stream);
+
+  priv->x11_display = x11_display;
+  priv->xwindow = requestor;
+  priv->selection = g_strdup (selection);
+  priv->xselection = XInternAtom (x11_display->xdisplay, priv->selection, False);
+  priv->target = g_strdup (target);
+  priv->xtarget = XInternAtom (x11_display->xdisplay, priv->target, False);
+  priv->property = g_strdup (property);
+  priv->xproperty = XInternAtom (x11_display->xdisplay, priv->property, False);
+  priv->type = g_strdup (type);
+  priv->xtype = XInternAtom (x11_display->xdisplay, priv->type, False);
+  priv->format = format;
+  priv->timestamp = timestamp;
+
+  return G_OUTPUT_STREAM (stream);
+}
diff --git a/src/x11/meta-x11-selection-private.h b/src/x11/meta-x11-selection-private.h
new file mode 100644
index 0000000000000000000000000000000000000000..b551ef6021bcb65fcaef5382413e3a88ad281fe0
--- /dev/null
+++ b/src/x11/meta-x11-selection-private.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#ifndef META_X11_SELECTION_H
+#define META_X11_SELECTION_H
+
+#include "meta/meta-selection.h"
+#include "x11/meta-x11-display-private.h"
+
+gboolean meta_x11_selection_handle_event (MetaX11Display *display,
+                                          XEvent         *event);
+
+void     meta_x11_selection_init     (MetaX11Display *x11_display);
+void     meta_x11_selection_shutdown (MetaX11Display *x11_display);
+
+#endif /* META_X11_SELECTION_H */
diff --git a/src/x11/meta-x11-selection.c b/src/x11/meta-x11-selection.c
new file mode 100644
index 0000000000000000000000000000000000000000..5b87c424ccf47f88bb8764b642c0211043794fca
--- /dev/null
+++ b/src/x11/meta-x11-selection.c
@@ -0,0 +1,411 @@
+/*
+ * Copyright (C) 2018 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Author: Carlos Garnacho <carlosg@gnome.org>
+ */
+
+#include "config.h"
+
+#include <gdk/gdkx.h>
+
+#include "x11/meta-selection-source-x11-private.h"
+#include "x11/meta-x11-selection-output-stream-private.h"
+#include "x11/meta-x11-selection-private.h"
+
+static gboolean
+atom_to_selection_type (Display           *xdisplay,
+                        Atom               selection,
+                        MetaSelectionType *selection_type)
+{
+  if (selection == XInternAtom (xdisplay, "PRIMARY", False))
+    *selection_type = META_SELECTION_PRIMARY;
+  else if (selection == XInternAtom (xdisplay, "CLIPBOARD", False))
+    *selection_type = META_SELECTION_CLIPBOARD;
+  else if (selection == XInternAtom (xdisplay, "XdndSelection", False))
+    *selection_type = META_SELECTION_DND;
+  else
+    return FALSE;
+
+  return TRUE;
+}
+
+static Atom
+selection_to_atom (MetaSelectionType  type,
+                   Display           *xdisplay)
+{
+  Atom atom;
+
+  switch (type)
+    {
+    case META_SELECTION_PRIMARY:
+      atom = XInternAtom (xdisplay, "PRIMARY", False);
+      break;
+    case META_SELECTION_CLIPBOARD:
+      atom = XInternAtom (xdisplay, "CLIPBOARD", False);
+      break;
+    case META_SELECTION_DND:
+      atom = XInternAtom (xdisplay, "XdndSelection", False);
+      break;
+    default:
+      g_warn_if_reached ();
+      atom = None;
+      break;
+    }
+
+  return atom;
+}
+
+static GBytes *
+mimetypes_to_bytes (GList   *mimetypes,
+                    Display *xdisplay)
+{
+  gint i = 0, len = g_list_length (mimetypes) + 2;
+  Atom *atoms = g_new0 (Atom, len);
+  GList *l;
+
+  for (l = mimetypes; l; l = l->next)
+    atoms[i++] = XInternAtom (xdisplay, l->data, False);
+
+  atoms[i++] = XInternAtom (xdisplay, "TARGETS", False);
+  atoms[i++] = XInternAtom (xdisplay, "TIMESTAMP", False);
+  g_assert (i == len);
+
+  return g_bytes_new_take (atoms, len * sizeof (Atom));
+}
+
+static void
+send_selection_notify (XSelectionRequestEvent *request_event,
+                       gboolean                accepted)
+{
+  Display *xdisplay = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  XSelectionEvent event;
+
+  memset(&event, 0, sizeof (XSelectionEvent));
+  event.type = SelectionNotify;
+  event.time = request_event->time;
+  event.requestor = request_event->requestor;
+  event.selection = request_event->selection;
+  event.target = request_event->target;
+  event.property = accepted ? request_event->property : None;
+
+  XSendEvent (xdisplay, request_event->requestor,
+              False, NoEventMask, (XEvent *) &event);
+}
+
+static void
+write_mimetypes_cb (GOutputStream *stream,
+                    GAsyncResult  *res,
+                    gpointer       user_data)
+{
+  GError *error = NULL;
+
+  g_output_stream_write_bytes_finish (stream, res, &error);
+  g_output_stream_close (stream, NULL, NULL);
+
+  if (error)
+    {
+      g_warning ("Could not fetch selection mimetypes: %s\n", error->message);
+      g_error_free (error);
+    }
+}
+
+static void
+transfer_cb (MetaSelection *selection,
+             GAsyncResult  *res,
+             GOutputStream *output)
+{
+  GError *error = NULL;
+
+  if (!meta_selection_transfer_finish (selection, res, &error))
+    {
+      g_warning ("Error writing data to X11 selection: %s", error->message);
+      g_error_free (error);
+    }
+
+  g_output_stream_close (output, NULL, NULL);
+  g_object_unref (output);
+}
+
+static gboolean
+meta_x11_selection_handle_selection_request (MetaX11Display *x11_display,
+                                             XEvent         *xevent)
+{
+  XSelectionRequestEvent *event = (XSelectionRequestEvent *) xevent;
+  MetaSelectionType selection_type;
+  MetaSelection *selection;
+  GOutputStream *output;
+  GList *mimetypes;
+
+  if (!atom_to_selection_type (x11_display->xdisplay, event->selection, &selection_type))
+    return FALSE;
+  if (x11_display->selection.xwindow != event->owner)
+    return FALSE;
+
+  selection = meta_display_get_selection (meta_get_display ());
+
+  if (event->target == gdk_x11_get_xatom_by_name ("TARGETS"))
+    {
+      GBytes *bytes;
+
+      mimetypes = meta_selection_get_mimetypes (selection, selection_type);
+
+      if (!mimetypes)
+        {
+          send_selection_notify (event, FALSE);
+          return FALSE;
+        }
+
+      output = meta_x11_selection_output_stream_new (x11_display, event->requestor,
+                                                     gdk_x11_get_xatom_name (event->selection),
+                                                     gdk_x11_get_xatom_name (event->target),
+                                                     gdk_x11_get_xatom_name (event->property),
+                                                     "ATOM", 32, event->time);
+
+      bytes = mimetypes_to_bytes (mimetypes, x11_display->xdisplay);
+      g_list_free_full (mimetypes, g_free);
+
+      g_output_stream_write_bytes_async (output,
+                                         bytes,
+                                         G_PRIORITY_DEFAULT,
+                                         NULL,
+                                         (GAsyncReadyCallback) write_mimetypes_cb,
+                                         output);
+      g_bytes_unref (bytes);
+      return TRUE;
+    }
+  else if (event->target == gdk_x11_get_xatom_by_name ("DELETE"))
+    {
+      /* DnD only, this is just handled through other means on our non-x11
+       * sources, so just go with it.
+       */
+      send_selection_notify (event, TRUE);
+    }
+  else
+    {
+      gboolean has_target;
+
+      mimetypes = meta_selection_get_mimetypes (selection, selection_type);
+      has_target = g_list_find_custom (mimetypes,
+                                       gdk_x11_get_xatom_name (event->target),
+                                       (GCompareFunc) g_strcmp0) != NULL;
+      g_list_free_full (mimetypes, g_free);
+
+      if (has_target)
+        {
+          output = meta_x11_selection_output_stream_new (x11_display,
+                                                         event->requestor,
+                                                         gdk_x11_get_xatom_name (event->selection),
+                                                         gdk_x11_get_xatom_name (event->target),
+                                                         gdk_x11_get_xatom_name (event->property),
+                                                         gdk_x11_get_xatom_name (event->target),
+                                                         8, event->time);
+
+          meta_selection_transfer_async (selection,
+                                         selection_type,
+                                         gdk_x11_get_xatom_name (event->target),
+                                         -1,
+                                         output,
+                                         NULL,
+                                         (GAsyncReadyCallback) transfer_cb,
+                                         output);
+          return TRUE;
+        }
+      else
+        send_selection_notify (event, FALSE);
+    }
+
+  return FALSE;
+}
+
+typedef struct
+{
+  MetaX11Display *x11_display;
+  MetaSelection *selection;
+  MetaSelectionType selection_type;
+} SourceNewData;
+
+static void
+source_new_cb (GObject      *object,
+               GAsyncResult *res,
+               gpointer      user_data)
+{
+  MetaSelectionSource *source;
+  SourceNewData *data = user_data;
+  MetaSelection *selection = data->selection;
+  MetaSelectionType selection_type = data->selection_type;
+  MetaX11Display *x11_display = data->x11_display;
+  GError *error = NULL;
+
+  source = meta_selection_source_x11_new_finish (res, &error);
+  if (source)
+    {
+      meta_selection_set_owner (selection, selection_type, source);
+      g_set_object (&x11_display->selection.owners[selection_type], source);
+    }
+  else
+    {
+      g_warning ("Could not create selection source for X11: %s",
+                 error->message);
+    }
+
+  g_free (data);
+}
+
+static gboolean
+meta_x11_selection_handle_xfixes_selection_notify (MetaX11Display *x11_display,
+                                                   XEvent         *xevent)
+{
+  XFixesSelectionNotifyEvent *event = (XFixesSelectionNotifyEvent *) xevent;
+  Display *xdisplay = x11_display->xdisplay;
+  MetaSelectionType selection_type;
+  MetaSelection *selection;
+
+  if (!atom_to_selection_type (xdisplay, event->selection, &selection_type))
+    return FALSE;
+
+  selection = meta_display_get_selection (meta_get_display ());
+
+  if (x11_display->selection.cancellables[selection_type])
+    {
+      g_cancellable_cancel (x11_display->selection.cancellables[selection_type]);
+      g_clear_object (&x11_display->selection.cancellables[selection_type]);
+    }
+
+  x11_display->selection.cancellables[selection_type] = g_cancellable_new ();
+
+  if (event->owner == None)
+    {
+      if (x11_display->selection.owners[selection_type])
+        {
+          /* An X client went away, clear the selection */
+          meta_selection_unset_owner (selection, selection_type,
+                                      x11_display->selection.owners[selection_type]);
+        }
+    }
+  else if (event->owner != x11_display->selection.xwindow)
+    {
+      SourceNewData *data;
+
+      data = g_new (SourceNewData, 1);
+      data->x11_display = x11_display;
+      data->selection = selection;
+      data->selection_type = selection_type;
+
+      meta_selection_source_x11_new_async (x11_display,
+                                           event->owner,
+                                           event->timestamp,
+                                           event->selection,
+                                           x11_display->selection.cancellables[selection_type],
+                                           source_new_cb,
+                                           data);
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_x11_selection_handle_event (MetaX11Display *x11_display,
+                                 XEvent         *xevent)
+{
+  if (xevent->type == SelectionRequest)
+    return meta_x11_selection_handle_selection_request (x11_display, xevent);
+  else if (xevent->type - x11_display->xfixes_event_base == XFixesSelectionNotify)
+    return meta_x11_selection_handle_xfixes_selection_notify (x11_display, xevent);
+
+  return FALSE;
+}
+
+static void
+owner_changed_cb (MetaSelection       *selection,
+                  MetaSelectionType    selection_type,
+                  MetaSelectionSource *new_owner,
+                  MetaX11Display      *x11_display)
+{
+  Display *xdisplay = x11_display->xdisplay;
+
+  if (new_owner && !META_IS_SELECTION_SOURCE_X11 (new_owner))
+    {
+      if (x11_display->selection.cancellables[selection_type])
+        {
+          g_cancellable_cancel (x11_display->selection.cancellables[selection_type]);
+          g_clear_object (&x11_display->selection.cancellables[selection_type]);
+        }
+
+      /* If the owner is non-X11, claim the selection on our selection
+       * window, so X11 apps can interface with it.
+       */
+      XSetSelectionOwner (xdisplay,
+                          selection_to_atom (selection_type, xdisplay),
+                          x11_display->selection.xwindow,
+                          META_CURRENT_TIME);
+    }
+}
+
+void
+meta_x11_selection_init (MetaX11Display *x11_display)
+{
+  XSetWindowAttributes attributes = { 0 };
+  MetaDisplay *display = meta_get_display ();
+  guint mask, i;
+
+  attributes.event_mask = PropertyChangeMask | SubstructureNotifyMask;
+  attributes.override_redirect = True;
+
+  x11_display->selection.xwindow =
+    XCreateWindow (x11_display->xdisplay,
+                   x11_display->xroot,
+                   -1, -1, 1, 1,
+                   0, /* border width */
+                   0, /* depth */
+                   InputOnly, /* class */
+                   CopyFromParent, /* visual */
+                   CWEventMask | CWOverrideRedirect,
+                   &attributes);
+
+  mask = XFixesSetSelectionOwnerNotifyMask |
+    XFixesSelectionWindowDestroyNotifyMask |
+    XFixesSelectionClientCloseNotifyMask;
+
+  for (i = 0; i < META_N_SELECTION_TYPES; i++)
+    {
+      XFixesSelectSelectionInput (x11_display->xdisplay,
+                                  x11_display->selection.xwindow,
+                                  selection_to_atom (i, x11_display->xdisplay),
+                                  mask);
+    }
+
+  g_signal_connect (meta_display_get_selection (display),
+                    "owner-changed",
+                    G_CALLBACK (owner_changed_cb),
+                    x11_display);
+}
+
+void
+meta_x11_selection_shutdown (MetaX11Display *x11_display)
+{
+  MetaDisplay *display = meta_get_display ();
+
+  g_signal_handlers_disconnect_by_func (meta_display_get_selection (display),
+                                        owner_changed_cb,
+                                        x11_display);
+  if (x11_display->selection.xwindow != None)
+    {
+      XDestroyWindow (x11_display->xdisplay, x11_display->selection.xwindow);
+      x11_display->selection.xwindow = None;
+    }
+}
